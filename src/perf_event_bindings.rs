/* automatically generated by rust-bindgen */

pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const BITS_PER_LONG: ::std::os::raw::c_uint = 32;
pub const BITS_PER_LONG_LONG: ::std::os::raw::c_uint = 64;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _IOC_NRBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_TYPEBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZEBITS: ::std::os::raw::c_uint = 14;
pub const _IOC_DIRBITS: ::std::os::raw::c_uint = 2;
pub const _IOC_NRMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_TYPEMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_SIZEMASK: ::std::os::raw::c_uint = 16383;
pub const _IOC_DIRMASK: ::std::os::raw::c_uint = 3;
pub const _IOC_NRSHIFT: ::std::os::raw::c_uint = 0;
pub const _IOC_TYPESHIFT: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZESHIFT: ::std::os::raw::c_uint = 16;
pub const _IOC_DIRSHIFT: ::std::os::raw::c_uint = 30;
pub const _IOC_NONE: ::std::os::raw::c_uint = 0;
pub const _IOC_WRITE: ::std::os::raw::c_uint = 1;
pub const _IOC_READ: ::std::os::raw::c_uint = 2;
pub const IOC_IN: ::std::os::raw::c_uint = 1073741824;
pub const IOC_OUT: ::std::os::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::std::os::raw::c_uint = 3221225472;
pub const IOCSIZE_MASK: ::std::os::raw::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: ::std::os::raw::c_uint = 16;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const PERF_ATTR_SIZE_VER0: ::std::os::raw::c_uint = 64;
pub const PERF_ATTR_SIZE_VER1: ::std::os::raw::c_uint = 72;
pub const PERF_ATTR_SIZE_VER2: ::std::os::raw::c_uint = 80;
pub const PERF_ATTR_SIZE_VER3: ::std::os::raw::c_uint = 96;
pub const PERF_ATTR_SIZE_VER4: ::std::os::raw::c_uint = 104;
pub const PERF_ATTR_SIZE_VER5: ::std::os::raw::c_uint = 112;
pub const PERF_RECORD_MISC_CPUMODE_MASK: ::std::os::raw::c_uint = 7;
pub const PERF_RECORD_MISC_CPUMODE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const PERF_RECORD_MISC_KERNEL: ::std::os::raw::c_uint = 1;
pub const PERF_RECORD_MISC_USER: ::std::os::raw::c_uint = 2;
pub const PERF_RECORD_MISC_HYPERVISOR: ::std::os::raw::c_uint = 3;
pub const PERF_RECORD_MISC_GUEST_KERNEL: ::std::os::raw::c_uint = 4;
pub const PERF_RECORD_MISC_GUEST_USER: ::std::os::raw::c_uint = 5;
pub const PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT: ::std::os::raw::c_uint =
    4096;
pub const PERF_RECORD_MISC_MMAP_DATA: ::std::os::raw::c_uint = 8192;
pub const PERF_RECORD_MISC_COMM_EXEC: ::std::os::raw::c_uint = 8192;
pub const PERF_RECORD_MISC_SWITCH_OUT: ::std::os::raw::c_uint = 8192;
pub const PERF_RECORD_MISC_EXACT_IP: ::std::os::raw::c_uint = 16384;
pub const PERF_RECORD_MISC_EXT_RESERVED: ::std::os::raw::c_uint = 32768;
pub const PERF_MAX_STACK_DEPTH: ::std::os::raw::c_uint = 127;
pub const PERF_AUX_FLAG_TRUNCATED: ::std::os::raw::c_uint = 1;
pub const PERF_AUX_FLAG_OVERWRITE: ::std::os::raw::c_uint = 2;
pub const PERF_FLAG_FD_NO_GROUP: ::std::os::raw::c_uint = 1;
pub const PERF_FLAG_FD_OUTPUT: ::std::os::raw::c_uint = 2;
pub const PERF_FLAG_PID_CGROUP: ::std::os::raw::c_uint = 4;
pub const PERF_FLAG_FD_CLOEXEC: ::std::os::raw::c_uint = 8;
pub const PERF_MEM_OP_NA: ::std::os::raw::c_uint = 1;
pub const PERF_MEM_OP_LOAD: ::std::os::raw::c_uint = 2;
pub const PERF_MEM_OP_STORE: ::std::os::raw::c_uint = 4;
pub const PERF_MEM_OP_PFETCH: ::std::os::raw::c_uint = 8;
pub const PERF_MEM_OP_EXEC: ::std::os::raw::c_uint = 16;
pub const PERF_MEM_OP_SHIFT: ::std::os::raw::c_uint = 0;
pub const PERF_MEM_LVL_NA: ::std::os::raw::c_uint = 1;
pub const PERF_MEM_LVL_HIT: ::std::os::raw::c_uint = 2;
pub const PERF_MEM_LVL_MISS: ::std::os::raw::c_uint = 4;
pub const PERF_MEM_LVL_L1: ::std::os::raw::c_uint = 8;
pub const PERF_MEM_LVL_LFB: ::std::os::raw::c_uint = 16;
pub const PERF_MEM_LVL_L2: ::std::os::raw::c_uint = 32;
pub const PERF_MEM_LVL_L3: ::std::os::raw::c_uint = 64;
pub const PERF_MEM_LVL_LOC_RAM: ::std::os::raw::c_uint = 128;
pub const PERF_MEM_LVL_REM_RAM1: ::std::os::raw::c_uint = 256;
pub const PERF_MEM_LVL_REM_RAM2: ::std::os::raw::c_uint = 512;
pub const PERF_MEM_LVL_REM_CCE1: ::std::os::raw::c_uint = 1024;
pub const PERF_MEM_LVL_REM_CCE2: ::std::os::raw::c_uint = 2048;
pub const PERF_MEM_LVL_IO: ::std::os::raw::c_uint = 4096;
pub const PERF_MEM_LVL_UNC: ::std::os::raw::c_uint = 8192;
pub const PERF_MEM_LVL_SHIFT: ::std::os::raw::c_uint = 5;
pub const PERF_MEM_SNOOP_NA: ::std::os::raw::c_uint = 1;
pub const PERF_MEM_SNOOP_NONE: ::std::os::raw::c_uint = 2;
pub const PERF_MEM_SNOOP_HIT: ::std::os::raw::c_uint = 4;
pub const PERF_MEM_SNOOP_MISS: ::std::os::raw::c_uint = 8;
pub const PERF_MEM_SNOOP_HITM: ::std::os::raw::c_uint = 16;
pub const PERF_MEM_SNOOP_SHIFT: ::std::os::raw::c_uint = 19;
pub const PERF_MEM_LOCK_NA: ::std::os::raw::c_uint = 1;
pub const PERF_MEM_LOCK_LOCKED: ::std::os::raw::c_uint = 2;
pub const PERF_MEM_LOCK_SHIFT: ::std::os::raw::c_uint = 24;
pub const PERF_MEM_TLB_NA: ::std::os::raw::c_uint = 1;
pub const PERF_MEM_TLB_HIT: ::std::os::raw::c_uint = 2;
pub const PERF_MEM_TLB_MISS: ::std::os::raw::c_uint = 4;
pub const PERF_MEM_TLB_L1: ::std::os::raw::c_uint = 8;
pub const PERF_MEM_TLB_L2: ::std::os::raw::c_uint = 16;
pub const PERF_MEM_TLB_WK: ::std::os::raw::c_uint = 32;
pub const PERF_MEM_TLB_OS: ::std::os::raw::c_uint = 64;
pub const PERF_MEM_TLB_SHIFT: ::std::os::raw::c_uint = 26;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type s8 = ::std::os::raw::c_schar;
pub type u8 = ::std::os::raw::c_uchar;
pub type s16 = ::std::os::raw::c_short;
pub type u16 = ::std::os::raw::c_ushort;
pub type s32 = ::std::os::raw::c_int;
pub type u32 = ::std::os::raw::c_uint;
pub type s64 = ::std::os::raw::c_longlong;
pub type u64 = ::std::os::raw::c_ulonglong;
pub const false_: _bindgen_ty_1 = _bindgen_ty_1::false_;
pub const true_: _bindgen_ty_1 = _bindgen_ty_1::true_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 { false_ = 0, true_ = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __kernel_dev_t = __u32;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ino_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = ::std::os::raw::c_ushort;
pub type nlink_t = __u32;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type loff_t = __kernel_loff_t;
pub type time_t = __kernel_time_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type unchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type u_int8_t = __u8;
pub type u_int16_t = __u16;
pub type u_int32_t = __u32;
pub type u_int64_t = __u64;
pub type sector_t = ::std::os::raw::c_ulong;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type dma_addr_t = u32;
pub type gfp_t = ::std::os::raw::c_uint;
pub type fmode_t = ::std::os::raw::c_uint;
pub type oom_flags_t = ::std::os::raw::c_uint;
pub type phys_addr_t = u32;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct atomic_t {
    pub counter: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(::std::mem::size_of::<atomic_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( atomic_t ) ));
    assert_eq! (::std::mem::align_of::<atomic_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( atomic_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const atomic_t ) ) . counter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( atomic_t ) , "::" ,
                stringify ! ( counter ) ));
}
impl Clone for atomic_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(::std::mem::size_of::<list_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( list_head ) ));
    assert_eq! (::std::mem::align_of::<list_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( list_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const list_head ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( list_head ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const list_head ) ) . prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( list_head ) , "::" ,
                stringify ! ( prev ) ));
}
impl Clone for list_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(::std::mem::size_of::<hlist_head>() , 8usize , concat ! (
               "Size of: " , stringify ! ( hlist_head ) ));
    assert_eq! (::std::mem::align_of::<hlist_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( hlist_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hlist_head ) ) . first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hlist_head ) , "::" ,
                stringify ! ( first ) ));
}
impl Clone for hlist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(::std::mem::size_of::<hlist_node>() , 16usize , concat ! (
               "Size of: " , stringify ! ( hlist_node ) ));
    assert_eq! (::std::mem::align_of::<hlist_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( hlist_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hlist_node ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hlist_node ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hlist_node ) ) . pprev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hlist_node ) , "::" ,
                stringify ! ( pprev ) ));
}
impl Clone for hlist_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: __kernel_ino_t,
    pub f_fname: [::std::os::raw::c_char; 6usize],
    pub f_fpack: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_ustat() {
    assert_eq!(::std::mem::size_of::<ustat>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ustat ) ));
    assert_eq! (::std::mem::align_of::<ustat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ustat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_tfree as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_tfree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_tinode as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_tinode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_fname as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_fname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_fpack as * const _ as usize
                } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_fpack ) ));
}
impl Clone for ustat {
    fn clone(&self) -> Self { *self }
}
/// struct callback_head - callback structure for use with RCU and task_work
/// @next: next update requests in a list
/// @func: actual update function to call after the grace period.
///
/// The struct is aligned to size of pointer. On most architectures it happens
/// naturally due ABI requirements, but some architectures (like CRIS) have
/// weird ABI and we need to ask it explicitly.
///
/// The alignment is required to guarantee that bits 0 and 1 of @next will be
/// clear under normal conditions -- as long as we use call_rcu(),
/// call_rcu_bh(), call_rcu_sched(), or call_srcu() to queue callback.
///
/// This guarantee is important for few reasons:
/// - future call_rcu_lazy() will make use of lower bits in the pointer;
/// - the structure shares storage spacer in struct page with @compound_head,
/// which encode PageTail() in bit 0. The guarantee is needed to avoid
/// false-positive PageTail().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::std::option::Option<unsafe extern "C" fn(head:
                                                             *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(::std::mem::size_of::<callback_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( callback_head ) ));
    assert_eq! (::std::mem::align_of::<callback_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callback_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callback_head ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callback_head ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callback_head ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callback_head ) , "::"
                , stringify ! ( func ) ));
}
impl Clone for callback_head {
    fn clone(&self) -> Self { *self }
}
pub type rcu_callback_t =
    ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head,
                                               func: rcu_callback_t)>;
pub type cycle_t = u64;
extern "C" {
    #[link_name = "__invalid_size_argument_for_IOC"]
    pub static mut __invalid_size_argument_for_IOC: ::std::os::raw::c_uint;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_type_id {
    PERF_TYPE_HARDWARE = 0,
    PERF_TYPE_SOFTWARE = 1,
    PERF_TYPE_TRACEPOINT = 2,
    PERF_TYPE_HW_CACHE = 3,
    PERF_TYPE_RAW = 4,
    PERF_TYPE_BREAKPOINT = 5,
    PERF_TYPE_MAX = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_hw_id {
    PERF_COUNT_HW_CPU_CYCLES = 0,
    PERF_COUNT_HW_INSTRUCTIONS = 1,
    PERF_COUNT_HW_CACHE_REFERENCES = 2,
    PERF_COUNT_HW_CACHE_MISSES = 3,
    PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
    PERF_COUNT_HW_BRANCH_MISSES = 5,
    PERF_COUNT_HW_BUS_CYCLES = 6,
    PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
    PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
    PERF_COUNT_HW_REF_CPU_CYCLES = 9,
    PERF_COUNT_HW_MAX = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_hw_cache_id {
    PERF_COUNT_HW_CACHE_L1D = 0,
    PERF_COUNT_HW_CACHE_L1I = 1,
    PERF_COUNT_HW_CACHE_LL = 2,
    PERF_COUNT_HW_CACHE_DTLB = 3,
    PERF_COUNT_HW_CACHE_ITLB = 4,
    PERF_COUNT_HW_CACHE_BPU = 5,
    PERF_COUNT_HW_CACHE_NODE = 6,
    PERF_COUNT_HW_CACHE_MAX = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_hw_cache_op_id {
    PERF_COUNT_HW_CACHE_OP_READ = 0,
    PERF_COUNT_HW_CACHE_OP_WRITE = 1,
    PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
    PERF_COUNT_HW_CACHE_OP_MAX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_hw_cache_op_result_id {
    PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
    PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
    PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_sw_ids {
    PERF_COUNT_SW_CPU_CLOCK = 0,
    PERF_COUNT_SW_TASK_CLOCK = 1,
    PERF_COUNT_SW_PAGE_FAULTS = 2,
    PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
    PERF_COUNT_SW_CPU_MIGRATIONS = 4,
    PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
    PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
    PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
    PERF_COUNT_SW_EMULATION_FAULTS = 8,
    PERF_COUNT_SW_DUMMY = 9,
    PERF_COUNT_SW_BPF_OUTPUT = 10,
    PERF_COUNT_SW_MAX = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_event_sample_format {
    PERF_SAMPLE_IP = 1,
    PERF_SAMPLE_TID = 2,
    PERF_SAMPLE_TIME = 4,
    PERF_SAMPLE_ADDR = 8,
    PERF_SAMPLE_READ = 16,
    PERF_SAMPLE_CALLCHAIN = 32,
    PERF_SAMPLE_ID = 64,
    PERF_SAMPLE_CPU = 128,
    PERF_SAMPLE_PERIOD = 256,
    PERF_SAMPLE_STREAM_ID = 512,
    PERF_SAMPLE_RAW = 1024,
    PERF_SAMPLE_BRANCH_STACK = 2048,
    PERF_SAMPLE_REGS_USER = 4096,
    PERF_SAMPLE_STACK_USER = 8192,
    PERF_SAMPLE_WEIGHT = 16384,
    PERF_SAMPLE_DATA_SRC = 32768,
    PERF_SAMPLE_IDENTIFIER = 65536,
    PERF_SAMPLE_TRANSACTION = 131072,
    PERF_SAMPLE_REGS_INTR = 262144,
    PERF_SAMPLE_MAX = 524288,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_branch_sample_type_shift {
    PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
    PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
    PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
    PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
    PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
    PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
    PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
    PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
    PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
    PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
    PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
    PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
    PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
    PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
    PERF_SAMPLE_BRANCH_MAX_SHIFT = 14,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_branch_sample_type {
    PERF_SAMPLE_BRANCH_USER = 1,
    PERF_SAMPLE_BRANCH_KERNEL = 2,
    PERF_SAMPLE_BRANCH_HV = 4,
    PERF_SAMPLE_BRANCH_ANY = 8,
    PERF_SAMPLE_BRANCH_ANY_CALL = 16,
    PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
    PERF_SAMPLE_BRANCH_IND_CALL = 64,
    PERF_SAMPLE_BRANCH_ABORT_TX = 128,
    PERF_SAMPLE_BRANCH_IN_TX = 256,
    PERF_SAMPLE_BRANCH_NO_TX = 512,
    PERF_SAMPLE_BRANCH_COND = 1024,
    PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
    PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
    PERF_SAMPLE_BRANCH_CALL = 8192,
    PERF_SAMPLE_BRANCH_MAX = 16384,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_sample_regs_abi {
    PERF_SAMPLE_REGS_ABI_NONE = 0,
    PERF_SAMPLE_REGS_ABI_32 = 1,
    PERF_SAMPLE_REGS_ABI_64 = 2,
}
pub const PERF_TXN_ELISION: _bindgen_ty_2 = _bindgen_ty_2::PERF_TXN_ELISION;
pub const PERF_TXN_TRANSACTION: _bindgen_ty_2 =
    _bindgen_ty_2::PERF_TXN_TRANSACTION;
pub const PERF_TXN_SYNC: _bindgen_ty_2 = _bindgen_ty_2::PERF_TXN_SYNC;
pub const PERF_TXN_ASYNC: _bindgen_ty_2 = _bindgen_ty_2::PERF_TXN_ASYNC;
pub const PERF_TXN_RETRY: _bindgen_ty_2 = _bindgen_ty_2::PERF_TXN_RETRY;
pub const PERF_TXN_CONFLICT: _bindgen_ty_2 = _bindgen_ty_2::PERF_TXN_CONFLICT;
pub const PERF_TXN_CAPACITY_WRITE: _bindgen_ty_2 =
    _bindgen_ty_2::PERF_TXN_CAPACITY_WRITE;
pub const PERF_TXN_CAPACITY_READ: _bindgen_ty_2 =
    _bindgen_ty_2::PERF_TXN_CAPACITY_READ;
pub const PERF_TXN_MAX: _bindgen_ty_2 = _bindgen_ty_2::PERF_TXN_MAX;
pub const PERF_TXN_ABORT_MASK: _bindgen_ty_2 =
    _bindgen_ty_2::PERF_TXN_ABORT_MASK;
pub const PERF_TXN_ABORT_SHIFT: _bindgen_ty_2 =
    _bindgen_ty_2::PERF_TXN_CONFLICT;
#[repr(u64)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    PERF_TXN_ELISION = 1,
    PERF_TXN_TRANSACTION = 2,
    PERF_TXN_SYNC = 4,
    PERF_TXN_ASYNC = 8,
    PERF_TXN_RETRY = 16,
    PERF_TXN_CONFLICT = 32,
    PERF_TXN_CAPACITY_WRITE = 64,
    PERF_TXN_CAPACITY_READ = 128,
    PERF_TXN_MAX = 256,
    PERF_TXN_ABORT_MASK = 18446744069414584320,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_event_read_format {
    PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
    PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
    PERF_FORMAT_ID = 4,
    PERF_FORMAT_GROUP = 8,
    PERF_FORMAT_MAX = 16,
}
#[repr(C)]
#[derive(Copy)]
pub struct perf_event_attr {
    pub type_: __u32,
    pub size: __u32,
    pub config: __u64,
    pub __bindgen_anon_1: perf_event_attr__bindgen_ty_1,
    pub sample_type: __u64,
    pub read_format: __u64,
    pub _bitfield_1: u64,
    pub __bindgen_anon_2: perf_event_attr__bindgen_ty_2,
    pub bp_type: __u32,
    pub __bindgen_anon_3: perf_event_attr__bindgen_ty_3,
    pub __bindgen_anon_4: perf_event_attr__bindgen_ty_4,
    pub branch_sample_type: __u64,
    pub sample_regs_user: __u64,
    pub sample_stack_user: __u32,
    pub clockid: __s32,
    pub sample_regs_intr: __u64,
    pub aux_watermark: __u32,
    pub __reserved_2: __u32,
}
#[repr(C)]
#[derive(Copy)]
pub union perf_event_attr__bindgen_ty_1 {
    pub sample_period: __u64,
    pub sample_freq: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<perf_event_attr__bindgen_ty_1>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( perf_event_attr__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<perf_event_attr__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( perf_event_attr__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_1 ) ) .
                sample_period as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_1 ) , "::" , stringify ! (
                sample_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_1 ) ) .
                sample_freq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_1 ) , "::" , stringify ! (
                sample_freq ) ));
}
impl Clone for perf_event_attr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union perf_event_attr__bindgen_ty_2 {
    pub wakeup_events: __u32,
    pub wakeup_watermark: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<perf_event_attr__bindgen_ty_2>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( perf_event_attr__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<perf_event_attr__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( perf_event_attr__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_2 ) ) .
                wakeup_events as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_2 ) , "::" , stringify ! (
                wakeup_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_2 ) ) .
                wakeup_watermark as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_2 ) , "::" , stringify ! (
                wakeup_watermark ) ));
}
impl Clone for perf_event_attr__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union perf_event_attr__bindgen_ty_3 {
    pub bp_addr: __u64,
    pub config1: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<perf_event_attr__bindgen_ty_3>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( perf_event_attr__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<perf_event_attr__bindgen_ty_3>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( perf_event_attr__bindgen_ty_3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_3 ) ) .
                bp_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_3 ) , "::" , stringify ! ( bp_addr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_3 ) ) .
                config1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_3 ) , "::" , stringify ! ( config1
                ) ));
}
impl Clone for perf_event_attr__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union perf_event_attr__bindgen_ty_4 {
    pub bp_len: __u64,
    pub config2: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<perf_event_attr__bindgen_ty_4>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( perf_event_attr__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<perf_event_attr__bindgen_ty_4>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( perf_event_attr__bindgen_ty_4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_4 ) ) .
                bp_len as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_4 ) , "::" , stringify ! ( bp_len
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr__bindgen_ty_4 ) ) .
                config2 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_attr__bindgen_ty_4 ) , "::" , stringify ! ( config2
                ) ));
}
impl Clone for perf_event_attr__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_perf_event_attr() {
    assert_eq!(::std::mem::size_of::<perf_event_attr>() , 112usize , concat !
               ( "Size of: " , stringify ! ( perf_event_attr ) ));
    assert_eq! (::std::mem::align_of::<perf_event_attr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( perf_event_attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . size as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . config as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . sample_type as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( sample_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . read_format as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( read_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . bp_type as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( bp_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . branch_sample_type
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( branch_sample_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . sample_regs_user as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( sample_regs_user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . sample_stack_user
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( sample_stack_user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . clockid as * const
                _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( clockid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . sample_regs_intr as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( sample_regs_intr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . aux_watermark as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( aux_watermark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_attr ) ) . __reserved_2 as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_attr ) ,
                "::" , stringify ! ( __reserved_2 ) ));
}
impl Clone for perf_event_attr {
    fn clone(&self) -> Self { *self }
}
impl perf_event_attr {
    #[inline]
    pub fn disabled(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: __u64) {
        let mask = 1u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn inherit(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 2u64 as u64;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_inherit(&mut self, val: __u64) {
        let mask = 2u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pinned(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4u64 as u64;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pinned(&mut self, val: __u64) {
        let mask = 4u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclusive(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8u64 as u64;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclusive(&mut self, val: __u64) {
        let mask = 8u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_user(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16u64 as u64;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_user(&mut self, val: __u64) {
        let mask = 16u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_kernel(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 32u64 as u64;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_kernel(&mut self, val: __u64) {
        let mask = 32u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_hv(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 64u64 as u64;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_hv(&mut self, val: __u64) {
        let mask = 64u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_idle(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 128u64 as u64;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_idle(&mut self, val: __u64) {
        let mask = 128u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mmap(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 256u64 as u64;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: __u64) {
        let mask = 256u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn comm(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 512u64 as u64;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_comm(&mut self, val: __u64) {
        let mask = 512u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn freq(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1024u64 as u64;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_freq(&mut self, val: __u64) {
        let mask = 1024u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn inherit_stat(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 2048u64 as u64;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_inherit_stat(&mut self, val: __u64) {
        let mask = 2048u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn enable_on_exec(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4096u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_enable_on_exec(&mut self, val: __u64) {
        let mask = 4096u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn task(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8192u64 as u64;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_task(&mut self, val: __u64) {
        let mask = 8192u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn watermark(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16384u64 as u64;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_watermark(&mut self, val: __u64) {
        let mask = 16384u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn precise_ip(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 98304u64 as u64;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_precise_ip(&mut self, val: __u64) {
        let mask = 98304u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mmap_data(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 131072u64 as u64;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mmap_data(&mut self, val: __u64) {
        let mask = 131072u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn sample_id_all(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 262144u64 as u64;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_sample_id_all(&mut self, val: __u64) {
        let mask = 262144u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_host(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 524288u64 as u64;
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_host(&mut self, val: __u64) {
        let mask = 524288u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_guest(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1048576u64 as u64;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_guest(&mut self, val: __u64) {
        let mask = 1048576u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_callchain_kernel(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 2097152u64 as u64;
        let val = (unit_field_val & mask) >> 21usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_kernel(&mut self, val: __u64) {
        let mask = 2097152u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 21usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn exclude_callchain_user(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4194304u64 as u64;
        let val = (unit_field_val & mask) >> 22usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_user(&mut self, val: __u64) {
        let mask = 4194304u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 22usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mmap2(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8388608u64 as u64;
        let val = (unit_field_val & mask) >> 23usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mmap2(&mut self, val: __u64) {
        let mask = 8388608u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 23usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn comm_exec(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16777216u64 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_comm_exec(&mut self, val: __u64) {
        let mask = 16777216u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn use_clockid(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 33554432u64 as u64;
        let val = (unit_field_val & mask) >> 25usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_use_clockid(&mut self, val: __u64) {
        let mask = 33554432u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 25usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn context_switch(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 67108864u64 as u64;
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_context_switch(&mut self, val: __u64) {
        let mask = 67108864u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18446744073575333888u64 as u64;
        let val = (unit_field_val & mask) >> 27usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: __u64) {
        let mask = 18446744073575333888u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 27usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(disabled: __u64, inherit: __u64, pinned: __u64,
                          exclusive: __u64, exclude_user: __u64,
                          exclude_kernel: __u64, exclude_hv: __u64,
                          exclude_idle: __u64, mmap: __u64, comm: __u64,
                          freq: __u64, inherit_stat: __u64,
                          enable_on_exec: __u64, task: __u64,
                          watermark: __u64, precise_ip: __u64,
                          mmap_data: __u64, sample_id_all: __u64,
                          exclude_host: __u64, exclude_guest: __u64,
                          exclude_callchain_kernel: __u64,
                          exclude_callchain_user: __u64, mmap2: __u64,
                          comm_exec: __u64, use_clockid: __u64,
                          context_switch: __u64, __reserved_1: __u64) -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              ({
                                                                                   ({
                                                                                        ({
                                                                                             ({
                                                                                                  ({
                                                                                                       ({
                                                                                                            ({
                                                                                                                 ({
                                                                                                                      ({
                                                                                                                           ({
                                                                                                                                ({
                                                                                                                                     ({
                                                                                                                                          ({
                                                                                                                                               0
                                                                                                                                           }
                                                                                                                                               |
                                                                                                                                               ((disabled
                                                                                                                                                     as
                                                                                                                                                     u64
                                                                                                                                                     as
                                                                                                                                                     u64)
                                                                                                                                                    <<
                                                                                                                                                    0usize)
                                                                                                                                                   &
                                                                                                                                                   (1u64
                                                                                                                                                        as
                                                                                                                                                        u64))
                                                                                                                                      }
                                                                                                                                          |
                                                                                                                                          ((inherit
                                                                                                                                                as
                                                                                                                                                u64
                                                                                                                                                as
                                                                                                                                                u64)
                                                                                                                                               <<
                                                                                                                                               1usize)
                                                                                                                                              &
                                                                                                                                              (2u64
                                                                                                                                                   as
                                                                                                                                                   u64))
                                                                                                                                 }
                                                                                                                                     |
                                                                                                                                     ((pinned
                                                                                                                                           as
                                                                                                                                           u64
                                                                                                                                           as
                                                                                                                                           u64)
                                                                                                                                          <<
                                                                                                                                          2usize)
                                                                                                                                         &
                                                                                                                                         (4u64
                                                                                                                                              as
                                                                                                                                              u64))
                                                                                                                            }
                                                                                                                                |
                                                                                                                                ((exclusive
                                                                                                                                      as
                                                                                                                                      u64
                                                                                                                                      as
                                                                                                                                      u64)
                                                                                                                                     <<
                                                                                                                                     3usize)
                                                                                                                                    &
                                                                                                                                    (8u64
                                                                                                                                         as
                                                                                                                                         u64))
                                                                                                                       }
                                                                                                                           |
                                                                                                                           ((exclude_user
                                                                                                                                 as
                                                                                                                                 u64
                                                                                                                                 as
                                                                                                                                 u64)
                                                                                                                                <<
                                                                                                                                4usize)
                                                                                                                               &
                                                                                                                               (16u64
                                                                                                                                    as
                                                                                                                                    u64))
                                                                                                                  }
                                                                                                                      |
                                                                                                                      ((exclude_kernel
                                                                                                                            as
                                                                                                                            u64
                                                                                                                            as
                                                                                                                            u64)
                                                                                                                           <<
                                                                                                                           5usize)
                                                                                                                          &
                                                                                                                          (32u64
                                                                                                                               as
                                                                                                                               u64))
                                                                                                             }
                                                                                                                 |
                                                                                                                 ((exclude_hv
                                                                                                                       as
                                                                                                                       u64
                                                                                                                       as
                                                                                                                       u64)
                                                                                                                      <<
                                                                                                                      6usize)
                                                                                                                     &
                                                                                                                     (64u64
                                                                                                                          as
                                                                                                                          u64))
                                                                                                        }
                                                                                                            |
                                                                                                            ((exclude_idle
                                                                                                                  as
                                                                                                                  u64
                                                                                                                  as
                                                                                                                  u64)
                                                                                                                 <<
                                                                                                                 7usize)
                                                                                                                &
                                                                                                                (128u64
                                                                                                                     as
                                                                                                                     u64))
                                                                                                   }
                                                                                                       |
                                                                                                       ((mmap
                                                                                                             as
                                                                                                             u64
                                                                                                             as
                                                                                                             u64)
                                                                                                            <<
                                                                                                            8usize)
                                                                                                           &
                                                                                                           (256u64
                                                                                                                as
                                                                                                                u64))
                                                                                              }
                                                                                                  |
                                                                                                  ((comm
                                                                                                        as
                                                                                                        u64
                                                                                                        as
                                                                                                        u64)
                                                                                                       <<
                                                                                                       9usize)
                                                                                                      &
                                                                                                      (512u64
                                                                                                           as
                                                                                                           u64))
                                                                                         }
                                                                                             |
                                                                                             ((freq
                                                                                                   as
                                                                                                   u64
                                                                                                   as
                                                                                                   u64)
                                                                                                  <<
                                                                                                  10usize)
                                                                                                 &
                                                                                                 (1024u64
                                                                                                      as
                                                                                                      u64))
                                                                                    }
                                                                                        |
                                                                                        ((inherit_stat
                                                                                              as
                                                                                              u64
                                                                                              as
                                                                                              u64)
                                                                                             <<
                                                                                             11usize)
                                                                                            &
                                                                                            (2048u64
                                                                                                 as
                                                                                                 u64))
                                                                               }
                                                                                   |
                                                                                   ((enable_on_exec
                                                                                         as
                                                                                         u64
                                                                                         as
                                                                                         u64)
                                                                                        <<
                                                                                        12usize)
                                                                                       &
                                                                                       (4096u64
                                                                                            as
                                                                                            u64))
                                                                          } |
                                                                              ((task
                                                                                    as
                                                                                    u64
                                                                                    as
                                                                                    u64)
                                                                                   <<
                                                                                   13usize)
                                                                                  &
                                                                                  (8192u64
                                                                                       as
                                                                                       u64))
                                                                     } |
                                                                         ((watermark
                                                                               as
                                                                               u64
                                                                               as
                                                                               u64)
                                                                              <<
                                                                              14usize)
                                                                             &
                                                                             (16384u64
                                                                                  as
                                                                                  u64))
                                                                } |
                                                                    ((precise_ip
                                                                          as
                                                                          u64
                                                                          as
                                                                          u64)
                                                                         <<
                                                                         15usize)
                                                                        &
                                                                        (98304u64
                                                                             as
                                                                             u64))
                                                           } |
                                                               ((mmap_data as
                                                                     u64 as
                                                                     u64) <<
                                                                    17usize) &
                                                                   (131072u64
                                                                        as
                                                                        u64))
                                                      } |
                                                          ((sample_id_all as
                                                                u64 as u64) <<
                                                               18usize) &
                                                              (262144u64 as
                                                                   u64))
                                                 } |
                                                     ((exclude_host as u64 as
                                                           u64) << 19usize) &
                                                         (524288u64 as u64))
                                            } |
                                                ((exclude_guest as u64 as u64)
                                                     << 20usize) &
                                                    (1048576u64 as u64))
                                       } |
                                           ((exclude_callchain_kernel as u64
                                                 as u64) << 21usize) &
                                               (2097152u64 as u64))
                                  } |
                                      ((exclude_callchain_user as u64 as u64)
                                           << 22usize) & (4194304u64 as u64))
                             } |
                                 ((mmap2 as u64 as u64) << 23usize) &
                                     (8388608u64 as u64))
                        } |
                            ((comm_exec as u64 as u64) << 24usize) &
                                (16777216u64 as u64))
                   } |
                       ((use_clockid as u64 as u64) << 25usize) &
                           (33554432u64 as u64))
              } |
                  ((context_switch as u64 as u64) << 26usize) &
                      (67108864u64 as u64))
         } |
             ((__reserved_1 as u64 as u64) << 27usize) &
                 (18446744073575333888u64 as u64))
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_event_ioc_flags { PERF_IOC_FLAG_GROUP = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct perf_event_mmap_page {
    pub version: __u32,
    pub compat_version: __u32,
    pub lock: __u32,
    pub index: __u32,
    pub offset: __s64,
    pub time_enabled: __u64,
    pub time_running: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1,
    pub pmc_width: __u16,
    pub time_shift: __u16,
    pub time_mult: __u32,
    pub time_offset: __u64,
    pub time_zero: __u64,
    pub size: __u32,
    pub __reserved: [__u8; 948usize],
    pub data_head: __u64,
    pub data_tail: __u64,
    pub data_offset: __u64,
    pub data_size: __u64,
    pub aux_head: __u64,
    pub aux_tail: __u64,
    pub aux_offset: __u64,
    pub aux_size: __u64,
}
#[repr(C)]
#[derive(Copy)]
pub union perf_event_mmap_page__bindgen_ty_1 {
    pub capabilities: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u64,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 ) ));
}
impl Clone for perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cap_bit0(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_bit0(&mut self, val: __u64) {
        let mask = 1u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn cap_bit0_is_deprecated(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 2u64 as u64;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_bit0_is_deprecated(&mut self, val: __u64) {
        let mask = 2u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn cap_user_rdpmc(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4u64 as u64;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_user_rdpmc(&mut self, val: __u64) {
        let mask = 4u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn cap_user_time(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8u64 as u64;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_user_time(&mut self, val: __u64) {
        let mask = 8u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn cap_user_time_zero(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16u64 as u64;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_zero(&mut self, val: __u64) {
        let mask = 16u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn cap_____res(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18446744073709551584u64 as u64;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_____res(&mut self, val: __u64) {
        let mask = 18446744073709551584u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(cap_bit0: __u64, cap_bit0_is_deprecated: __u64,
                          cap_user_rdpmc: __u64, cap_user_time: __u64,
                          cap_user_time_zero: __u64, cap_____res: __u64)
     -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((cap_bit0 as u64 as u64) << 0usize) &
                                          (1u64 as u64))
                             } |
                                 ((cap_bit0_is_deprecated as u64 as u64) <<
                                      1usize) & (2u64 as u64))
                        } |
                            ((cap_user_rdpmc as u64 as u64) << 2usize) &
                                (4u64 as u64))
                   } |
                       ((cap_user_time as u64 as u64) << 3usize) &
                           (8u64 as u64))
              } |
                  ((cap_user_time_zero as u64 as u64) << 4usize) &
                      (16u64 as u64))
         } |
             ((cap_____res as u64 as u64) << 5usize) &
                 (18446744073709551584u64 as u64))
    }
}
#[test]
fn bindgen_test_layout_perf_event_mmap_page__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<perf_event_mmap_page__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( perf_event_mmap_page__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<perf_event_mmap_page__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                perf_event_mmap_page__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page__bindgen_ty_1 ) ) .
                capabilities as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                perf_event_mmap_page__bindgen_ty_1 ) , "::" , stringify ! (
                capabilities ) ));
}
impl Clone for perf_event_mmap_page__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_perf_event_mmap_page() {
    assert_eq!(::std::mem::size_of::<perf_event_mmap_page>() , 1088usize ,
               concat ! ( "Size of: " , stringify ! ( perf_event_mmap_page )
               ));
    assert_eq! (::std::mem::align_of::<perf_event_mmap_page>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( perf_event_mmap_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . compat_version
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( compat_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . lock as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . offset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . time_enabled
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( time_enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . time_running
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( time_running ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . pmc_width as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( pmc_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . time_shift as
                * const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( time_shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . time_mult as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( time_mult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . time_offset as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( time_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . time_zero as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( time_zero ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . size as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . __reserved as
                * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( __reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . data_head as *
                const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( data_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . data_tail as *
                const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( data_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . data_offset as
                * const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( data_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . data_size as *
                const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . aux_head as *
                const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( aux_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . aux_tail as *
                const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( aux_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . aux_offset as
                * const _ as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( aux_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_mmap_page ) ) . aux_size as *
                const _ as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_mmap_page )
                , "::" , stringify ! ( aux_size ) ));
}
impl Clone for perf_event_mmap_page {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct perf_event_header {
    pub type_: __u32,
    pub misc: __u16,
    pub size: __u16,
}
#[test]
fn bindgen_test_layout_perf_event_header() {
    assert_eq!(::std::mem::size_of::<perf_event_header>() , 8usize , concat !
               ( "Size of: " , stringify ! ( perf_event_header ) ));
    assert_eq! (::std::mem::align_of::<perf_event_header>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( perf_event_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_header ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_header ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_header ) ) . misc as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_header ) ,
                "::" , stringify ! ( misc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_event_header ) ) . size as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_event_header ) ,
                "::" , stringify ! ( size ) ));
}
impl Clone for perf_event_header {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_event_type {
    PERF_RECORD_MMAP = 1,
    PERF_RECORD_LOST = 2,
    PERF_RECORD_COMM = 3,
    PERF_RECORD_EXIT = 4,
    PERF_RECORD_THROTTLE = 5,
    PERF_RECORD_UNTHROTTLE = 6,
    PERF_RECORD_FORK = 7,
    PERF_RECORD_READ = 8,
    PERF_RECORD_SAMPLE = 9,
    PERF_RECORD_MMAP2 = 10,
    PERF_RECORD_AUX = 11,
    PERF_RECORD_ITRACE_START = 12,
    PERF_RECORD_LOST_SAMPLES = 13,
    PERF_RECORD_SWITCH = 14,
    PERF_RECORD_SWITCH_CPU_WIDE = 15,
    PERF_RECORD_MAX = 16,
}
#[repr(u64)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum perf_callchain_context {
    PERF_CONTEXT_HV = 18446744073709551584,
    PERF_CONTEXT_KERNEL = 18446744073709551488,
    PERF_CONTEXT_USER = 18446744073709551104,
    PERF_CONTEXT_GUEST = 18446744073709549568,
    PERF_CONTEXT_GUEST_KERNEL = 18446744073709549440,
    PERF_CONTEXT_GUEST_USER = 18446744073709549056,
    PERF_CONTEXT_MAX = 18446744073709547521,
}
#[repr(C)]
#[derive(Copy)]
pub union perf_mem_data_src {
    pub val: __u64,
    pub __bindgen_anon_1: perf_mem_data_src__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct perf_mem_data_src__bindgen_ty_1 {
    pub _bitfield_1: [u32; 2usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_perf_mem_data_src__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<perf_mem_data_src__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( perf_mem_data_src__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<perf_mem_data_src__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                perf_mem_data_src__bindgen_ty_1 ) ));
}
impl Clone for perf_mem_data_src__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl perf_mem_data_src__bindgen_ty_1 {
    #[inline]
    pub fn mem_op(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 31u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mem_op(&mut self, val: __u64) {
        let mask = 31u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mem_lvl(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 524256u64 as u64;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mem_lvl(&mut self, val: __u64) {
        let mask = 524256u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mem_snoop(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16252928u64 as u64;
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mem_snoop(&mut self, val: __u64) {
        let mask = 16252928u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mem_lock(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 50331648u64 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mem_lock(&mut self, val: __u64) {
        let mask = 50331648u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mem_dtlb(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8522825728u64 as u64;
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mem_dtlb(&mut self, val: __u64) {
        let mask = 8522825728u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mem_rsvd(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18446744065119617024u64 as u64;
        let val = (unit_field_val & mask) >> 33usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mem_rsvd(&mut self, val: __u64) {
        let mask = 18446744065119617024u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 33usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(mem_op: __u64, mem_lvl: __u64, mem_snoop: __u64,
                          mem_lock: __u64, mem_dtlb: __u64, mem_rsvd: __u64)
     -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((mem_op as u64 as u64) << 0usize) &
                                          (31u64 as u64))
                             } |
                                 ((mem_lvl as u64 as u64) << 5usize) &
                                     (524256u64 as u64))
                        } |
                            ((mem_snoop as u64 as u64) << 19usize) &
                                (16252928u64 as u64))
                   } |
                       ((mem_lock as u64 as u64) << 24usize) &
                           (50331648u64 as u64))
              } |
                  ((mem_dtlb as u64 as u64) << 26usize) &
                      (8522825728u64 as u64))
         } |
             ((mem_rsvd as u64 as u64) << 33usize) &
                 (18446744065119617024u64 as u64))
    }
}
#[test]
fn bindgen_test_layout_perf_mem_data_src() {
    assert_eq!(::std::mem::size_of::<perf_mem_data_src>() , 8usize , concat !
               ( "Size of: " , stringify ! ( perf_mem_data_src ) ));
    assert_eq! (::std::mem::align_of::<perf_mem_data_src>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( perf_mem_data_src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_mem_data_src ) ) . val as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_mem_data_src ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for perf_mem_data_src {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct perf_branch_entry {
    pub from: __u64,
    pub to: __u64,
    pub _bitfield_1: u64,
}
#[test]
fn bindgen_test_layout_perf_branch_entry() {
    assert_eq!(::std::mem::size_of::<perf_branch_entry>() , 24usize , concat !
               ( "Size of: " , stringify ! ( perf_branch_entry ) ));
    assert_eq! (::std::mem::align_of::<perf_branch_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( perf_branch_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_branch_entry ) ) . from as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_branch_entry ) ,
                "::" , stringify ! ( from ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const perf_branch_entry ) ) . to as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( perf_branch_entry ) ,
                "::" , stringify ! ( to ) ));
}
impl Clone for perf_branch_entry {
    fn clone(&self) -> Self { *self }
}
impl perf_branch_entry {
    #[inline]
    pub fn mispred(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mispred(&mut self, val: __u64) {
        let mask = 1u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn predicted(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 2u64 as u64;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_predicted(&mut self, val: __u64) {
        let mask = 2u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn in_tx(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4u64 as u64;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_in_tx(&mut self, val: __u64) {
        let mask = 4u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn abort(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8u64 as u64;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_abort(&mut self, val: __u64) {
        let mask = 8u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn cycles(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1048560u64 as u64;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cycles(&mut self, val: __u64) {
        let mask = 1048560u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18446744073708503040u64 as u64;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        let mask = 18446744073708503040u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(mispred: __u64, predicted: __u64, in_tx: __u64,
                          abort: __u64, cycles: __u64, reserved: __u64)
     -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((mispred as u64 as u64) << 0usize) &
                                          (1u64 as u64))
                             } |
                                 ((predicted as u64 as u64) << 1usize) &
                                     (2u64 as u64))
                        } | ((in_tx as u64 as u64) << 2usize) & (4u64 as u64))
                   } | ((abort as u64 as u64) << 3usize) & (8u64 as u64))
              } | ((cycles as u64 as u64) << 4usize) & (1048560u64 as u64))
         } |
             ((reserved as u64 as u64) << 20usize) &
                 (18446744073708503040u64 as u64))
    }
}
