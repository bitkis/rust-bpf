/* automatically generated by rust-bindgen */

pub const PERF_FLAG_FD_CLOEXEC: ::std::os::raw::c_uint = 8;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub const perf_type_id_PERF_TYPE_HARDWARE: perf_type_id = 0;
pub const perf_type_id_PERF_TYPE_SOFTWARE: perf_type_id = 1;
pub const perf_type_id_PERF_TYPE_TRACEPOINT: perf_type_id = 2;
pub const perf_type_id_PERF_TYPE_HW_CACHE: perf_type_id = 3;
pub const perf_type_id_PERF_TYPE_RAW: perf_type_id = 4;
pub const perf_type_id_PERF_TYPE_BREAKPOINT: perf_type_id = 5;
pub const perf_type_id_PERF_TYPE_MAX: perf_type_id = 6;
pub type perf_type_id = ::std::os::raw::c_uint;
pub const perf_sw_ids_PERF_COUNT_SW_CPU_CLOCK: perf_sw_ids = 0;
pub const perf_sw_ids_PERF_COUNT_SW_TASK_CLOCK: perf_sw_ids = 1;
pub const perf_sw_ids_PERF_COUNT_SW_PAGE_FAULTS: perf_sw_ids = 2;
pub const perf_sw_ids_PERF_COUNT_SW_CONTEXT_SWITCHES: perf_sw_ids = 3;
pub const perf_sw_ids_PERF_COUNT_SW_CPU_MIGRATIONS: perf_sw_ids = 4;
pub const perf_sw_ids_PERF_COUNT_SW_PAGE_FAULTS_MIN: perf_sw_ids = 5;
pub const perf_sw_ids_PERF_COUNT_SW_PAGE_FAULTS_MAJ: perf_sw_ids = 6;
pub const perf_sw_ids_PERF_COUNT_SW_ALIGNMENT_FAULTS: perf_sw_ids = 7;
pub const perf_sw_ids_PERF_COUNT_SW_EMULATION_FAULTS: perf_sw_ids = 8;
pub const perf_sw_ids_PERF_COUNT_SW_DUMMY: perf_sw_ids = 9;
pub const perf_sw_ids_PERF_COUNT_SW_BPF_OUTPUT: perf_sw_ids = 10;
pub const perf_sw_ids_PERF_COUNT_SW_MAX: perf_sw_ids = 11;
pub type perf_sw_ids = ::std::os::raw::c_uint;
pub const perf_event_sample_format_PERF_SAMPLE_IP: perf_event_sample_format = 1;
pub const perf_event_sample_format_PERF_SAMPLE_TID: perf_event_sample_format = 2;
pub const perf_event_sample_format_PERF_SAMPLE_TIME: perf_event_sample_format = 4;
pub const perf_event_sample_format_PERF_SAMPLE_ADDR: perf_event_sample_format = 8;
pub const perf_event_sample_format_PERF_SAMPLE_READ: perf_event_sample_format = 16;
pub const perf_event_sample_format_PERF_SAMPLE_CALLCHAIN: perf_event_sample_format = 32;
pub const perf_event_sample_format_PERF_SAMPLE_ID: perf_event_sample_format = 64;
pub const perf_event_sample_format_PERF_SAMPLE_CPU: perf_event_sample_format = 128;
pub const perf_event_sample_format_PERF_SAMPLE_PERIOD: perf_event_sample_format = 256;
pub const perf_event_sample_format_PERF_SAMPLE_STREAM_ID: perf_event_sample_format = 512;
pub const perf_event_sample_format_PERF_SAMPLE_RAW: perf_event_sample_format = 1024;
pub const perf_event_sample_format_PERF_SAMPLE_BRANCH_STACK: perf_event_sample_format = 2048;
pub const perf_event_sample_format_PERF_SAMPLE_REGS_USER: perf_event_sample_format = 4096;
pub const perf_event_sample_format_PERF_SAMPLE_STACK_USER: perf_event_sample_format = 8192;
pub const perf_event_sample_format_PERF_SAMPLE_WEIGHT: perf_event_sample_format = 16384;
pub const perf_event_sample_format_PERF_SAMPLE_DATA_SRC: perf_event_sample_format = 32768;
pub const perf_event_sample_format_PERF_SAMPLE_IDENTIFIER: perf_event_sample_format = 65536;
pub const perf_event_sample_format_PERF_SAMPLE_TRANSACTION: perf_event_sample_format = 131072;
pub const perf_event_sample_format_PERF_SAMPLE_REGS_INTR: perf_event_sample_format = 262144;
pub const perf_event_sample_format_PERF_SAMPLE_MAX: perf_event_sample_format = 524288;
pub type perf_event_sample_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_attr {
    pub type_: __u32,
    pub size: __u32,
    pub config: __u64,
    pub __bindgen_anon_1: perf_event_attr__bindgen_ty_1,
    pub sample_type: __u64,
    pub read_format: __u64,
    pub _bitfield_1: u64,
    pub __bindgen_anon_2: perf_event_attr__bindgen_ty_2,
    pub bp_type: __u32,
    pub __bindgen_anon_3: perf_event_attr__bindgen_ty_3,
    pub __bindgen_anon_4: perf_event_attr__bindgen_ty_4,
    pub branch_sample_type: __u64,
    pub sample_regs_user: __u64,
    pub sample_stack_user: __u32,
    pub clockid: __s32,
    pub sample_regs_intr: __u64,
    pub aux_watermark: __u32,
    pub __reserved_2: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_1 {
    pub sample_period: __u64,
    pub sample_freq: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_attr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(perf_event_attr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_attr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(perf_event_attr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_1)).sample_period as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_1),
            "::",
            stringify!(sample_period)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_1)).sample_freq as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_1),
            "::",
            stringify!(sample_freq)
        )
    );
}
impl Default for perf_event_attr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_2 {
    pub wakeup_events: __u32,
    pub wakeup_watermark: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_attr__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(perf_event_attr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_attr__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(perf_event_attr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_2)).wakeup_events as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_2),
            "::",
            stringify!(wakeup_events)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_2)).wakeup_watermark as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_2),
            "::",
            stringify!(wakeup_watermark)
        )
    );
}
impl Default for perf_event_attr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_3 {
    pub bp_addr: __u64,
    pub config1: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_attr__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(perf_event_attr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_attr__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(perf_event_attr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_3)).bp_addr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_3),
            "::",
            stringify!(bp_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_3)).config1 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_3),
            "::",
            stringify!(config1)
        )
    );
}
impl Default for perf_event_attr__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_4 {
    pub bp_len: __u64,
    pub config2: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_perf_event_attr__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_attr__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(perf_event_attr__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_attr__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(perf_event_attr__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_4)).bp_len as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_4),
            "::",
            stringify!(bp_len)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr__bindgen_ty_4)).config2 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr__bindgen_ty_4),
            "::",
            stringify!(config2)
        )
    );
}
impl Default for perf_event_attr__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_perf_event_attr() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_attr>(),
        112usize,
        concat!("Size of: ", stringify!(perf_event_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(perf_event_attr))
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).size as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).config as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).sample_type as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(sample_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).read_format as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(read_format)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).bp_type as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(bp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).branch_sample_type as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(branch_sample_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).sample_regs_user as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(sample_regs_user)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).sample_stack_user as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(sample_stack_user)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).clockid as *const _ as usize },
        92usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).sample_regs_intr as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(sample_regs_intr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).aux_watermark as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(aux_watermark)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_attr)).__reserved_2 as *const _ as usize },
        108usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_attr),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl Default for perf_event_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl perf_event_attr {
    #[inline]
    pub fn disabled(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x1 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: __u64) {
        let mask = 0x1 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn inherit(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x2 as u64;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_inherit(&mut self, val: __u64) {
        let mask = 0x2 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn pinned(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x4 as u64;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pinned(&mut self, val: __u64) {
        let mask = 0x4 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclusive(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x8 as u64;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclusive(&mut self, val: __u64) {
        let mask = 0x8 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_user(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x10 as u64;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_user(&mut self, val: __u64) {
        let mask = 0x10 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_kernel(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x20 as u64;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_kernel(&mut self, val: __u64) {
        let mask = 0x20 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_hv(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x40 as u64;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_hv(&mut self, val: __u64) {
        let mask = 0x40 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_idle(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x80 as u64;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_idle(&mut self, val: __u64) {
        let mask = 0x80 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn mmap(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x100 as u64;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: __u64) {
        let mask = 0x100 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn comm(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x200 as u64;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_comm(&mut self, val: __u64) {
        let mask = 0x200 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn freq(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x400 as u64;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_freq(&mut self, val: __u64) {
        let mask = 0x400 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn inherit_stat(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x800 as u64;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_inherit_stat(&mut self, val: __u64) {
        let mask = 0x800 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn enable_on_exec(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x1000 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_enable_on_exec(&mut self, val: __u64) {
        let mask = 0x1000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn task(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x2000 as u64;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_task(&mut self, val: __u64) {
        let mask = 0x2000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn watermark(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x4000 as u64;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_watermark(&mut self, val: __u64) {
        let mask = 0x4000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn precise_ip(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x18000 as u64;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_precise_ip(&mut self, val: __u64) {
        let mask = 0x18000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn mmap_data(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x20000 as u64;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mmap_data(&mut self, val: __u64) {
        let mask = 0x20000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn sample_id_all(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x40000 as u64;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_sample_id_all(&mut self, val: __u64) {
        let mask = 0x40000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_host(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x80000 as u64;
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_host(&mut self, val: __u64) {
        let mask = 0x80000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_guest(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x100000 as u64;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_guest(&mut self, val: __u64) {
        let mask = 0x100000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_callchain_kernel(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x200000 as u64;
        let val = (unit_field_val & mask) >> 21usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_kernel(&mut self, val: __u64) {
        let mask = 0x200000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 21usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn exclude_callchain_user(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x400000 as u64;
        let val = (unit_field_val & mask) >> 22usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_user(&mut self, val: __u64) {
        let mask = 0x400000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 22usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn mmap2(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x800000 as u64;
        let val = (unit_field_val & mask) >> 23usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mmap2(&mut self, val: __u64) {
        let mask = 0x800000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 23usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn comm_exec(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x1000000 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_comm_exec(&mut self, val: __u64) {
        let mask = 0x1000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn use_clockid(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x2000000 as u64;
        let val = (unit_field_val & mask) >> 25usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_use_clockid(&mut self, val: __u64) {
        let mask = 0x2000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 25usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn context_switch(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x4000000 as u64;
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_context_switch(&mut self, val: __u64) {
        let mask = 0x4000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xfffffffff8000000 as u64;
        let val = (unit_field_val & mask) >> 27usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: __u64) {
        let mask = 0xfffffffff8000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 27usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(disabled: __u64, inherit: __u64, pinned: __u64, exclusive: __u64, exclude_user: __u64, exclude_kernel: __u64, exclude_hv: __u64, exclude_idle: __u64, mmap: __u64, comm: __u64, freq: __u64, inherit_stat: __u64, enable_on_exec: __u64, task: __u64, watermark: __u64, precise_ip: __u64, mmap_data: __u64, sample_id_all: __u64, exclude_host: __u64, exclude_guest: __u64, exclude_callchain_kernel: __u64, exclude_callchain_user: __u64, mmap2: __u64, comm_exec: __u64, use_clockid: __u64, context_switch: __u64, __reserved_1: __u64) -> u64 {
        (((((((((((((((((((((((((((0 | ((disabled as u64 as u64) << 0usize) & (0x1 as u64)) | ((inherit as u64 as u64) << 1usize) & (0x2 as u64)) | ((pinned as u64 as u64) << 2usize) & (0x4 as u64)) | ((exclusive as u64 as u64) << 3usize) & (0x8 as u64)) | ((exclude_user as u64 as u64) << 4usize) & (0x10 as u64)) | ((exclude_kernel as u64 as u64) << 5usize) & (0x20 as u64)) | ((exclude_hv as u64 as u64) << 6usize) & (0x40 as u64)) | ((exclude_idle as u64 as u64) << 7usize) & (0x80 as u64)) | ((mmap as u64 as u64) << 8usize) & (0x100 as u64)) | ((comm as u64 as u64) << 9usize) & (0x200 as u64)) | ((freq as u64 as u64) << 10usize) & (0x400 as u64)) | ((inherit_stat as u64 as u64) << 11usize) & (0x800 as u64)) | ((enable_on_exec as u64 as u64) << 12usize) & (0x1000 as u64)) | ((task as u64 as u64) << 13usize) & (0x2000 as u64)) | ((watermark as u64 as u64) << 14usize) & (0x4000 as u64)) | ((precise_ip as u64 as u64) << 15usize) & (0x18000 as u64)) | ((mmap_data as u64 as u64) << 17usize) & (0x20000 as u64)) | ((sample_id_all as u64 as u64) << 18usize) & (0x40000 as u64)) | ((exclude_host as u64 as u64) << 19usize) & (0x80000 as u64)) | ((exclude_guest as u64 as u64) << 20usize) & (0x100000 as u64)) | ((exclude_callchain_kernel as u64 as u64) << 21usize) & (0x200000 as u64)) | ((exclude_callchain_user as u64 as u64) << 22usize) & (0x400000 as u64)) | ((mmap2 as u64 as u64) << 23usize) & (0x800000 as u64)) | ((comm_exec as u64 as u64) << 24usize) & (0x1000000 as u64)) | ((use_clockid as u64 as u64) << 25usize) & (0x2000000 as u64)) | ((context_switch as u64 as u64) << 26usize) & (0x4000000 as u64)) | ((__reserved_1 as u64 as u64) << 27usize) & (0xfffffffff8000000 as u64))
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_mmap_page {
    pub version: __u32,
    pub compat_version: __u32,
    pub lock: __u32,
    pub index: __u32,
    pub offset: __s64,
    pub time_enabled: __u64,
    pub time_running: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1,
    pub pmc_width: __u16,
    pub time_shift: __u16,
    pub time_mult: __u32,
    pub time_offset: __u64,
    pub time_zero: __u64,
    pub size: __u32,
    pub __reserved: [__u8; 948usize],
    pub data_head: __u64,
    pub data_tail: __u64,
    pub data_offset: __u64,
    pub data_size: __u64,
    pub aux_head: __u64,
    pub aux_tail: __u64,
    pub aux_offset: __u64,
    pub aux_size: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_mmap_page__bindgen_ty_1 {
    pub capabilities: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u64,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cap_bit0(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x1 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_bit0(&mut self, val: __u64) {
        let mask = 0x1 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn cap_bit0_is_deprecated(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x2 as u64;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_bit0_is_deprecated(&mut self, val: __u64) {
        let mask = 0x2 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn cap_user_rdpmc(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x4 as u64;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_user_rdpmc(&mut self, val: __u64) {
        let mask = 0x4 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn cap_user_time(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x8 as u64;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_user_time(&mut self, val: __u64) {
        let mask = 0x8 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn cap_user_time_zero(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x10 as u64;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_zero(&mut self, val: __u64) {
        let mask = 0x10 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn cap_____res(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xffffffffffffffe0 as u64;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_cap_____res(&mut self, val: __u64) {
        let mask = 0xffffffffffffffe0 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(cap_bit0: __u64, cap_bit0_is_deprecated: __u64, cap_user_rdpmc: __u64, cap_user_time: __u64, cap_user_time_zero: __u64, cap_____res: __u64) -> u64 {
        ((((((0 | ((cap_bit0 as u64 as u64) << 0usize) & (0x1 as u64)) | ((cap_bit0_is_deprecated as u64 as u64) << 1usize) & (0x2 as u64)) | ((cap_user_rdpmc as u64 as u64) << 2usize) & (0x4 as u64)) | ((cap_user_time as u64 as u64) << 3usize) & (0x8 as u64)) | ((cap_user_time_zero as u64 as u64) << 4usize) & (0x10 as u64)) | ((cap_____res as u64 as u64) << 5usize) & (0xffffffffffffffe0 as u64))
    }
}
#[test]
fn bindgen_test_layout_perf_event_mmap_page__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_mmap_page__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(perf_event_mmap_page__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_mmap_page__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(perf_event_mmap_page__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page__bindgen_ty_1)).capabilities as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page__bindgen_ty_1),
            "::",
            stringify!(capabilities)
        )
    );
}
impl Default for perf_event_mmap_page__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_perf_event_mmap_page() {
    assert_eq!(
        ::std::mem::size_of::<perf_event_mmap_page>(),
        1088usize,
        concat!("Size of: ", stringify!(perf_event_mmap_page))
    );
    assert_eq!(
        ::std::mem::align_of::<perf_event_mmap_page>(),
        8usize,
        concat!("Alignment of ", stringify!(perf_event_mmap_page))
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).version as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).compat_version as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(compat_version)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).lock as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).index as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).offset as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).time_enabled as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(time_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).time_running as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(time_running)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).pmc_width as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(pmc_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).time_shift as *const _ as usize },
        50usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(time_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).time_mult as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(time_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).time_offset as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(time_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).time_zero as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(time_zero)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).size as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).__reserved as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).data_head as *const _ as usize },
        1024usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(data_head)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).data_tail as *const _ as usize },
        1032usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(data_tail)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).data_offset as *const _ as usize },
        1040usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).data_size as *const _ as usize },
        1048usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).aux_head as *const _ as usize },
        1056usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(aux_head)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).aux_tail as *const _ as usize },
        1064usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(aux_tail)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).aux_offset as *const _ as usize },
        1072usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(aux_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const perf_event_mmap_page)).aux_size as *const _ as usize },
        1080usize,
        concat!(
            "Alignment of field: ",
            stringify!(perf_event_mmap_page),
            "::",
            stringify!(aux_size)
        )
    );
}
impl Default for perf_event_mmap_page {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
