/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const BPF_LD: ::std::os::raw::c_uint = 0;
pub const BPF_LDX: ::std::os::raw::c_uint = 1;
pub const BPF_ST: ::std::os::raw::c_uint = 2;
pub const BPF_STX: ::std::os::raw::c_uint = 3;
pub const BPF_ALU: ::std::os::raw::c_uint = 4;
pub const BPF_JMP: ::std::os::raw::c_uint = 5;
pub const BPF_RET: ::std::os::raw::c_uint = 6;
pub const BPF_MISC: ::std::os::raw::c_uint = 7;
pub const BPF_W: ::std::os::raw::c_uint = 0;
pub const BPF_H: ::std::os::raw::c_uint = 8;
pub const BPF_B: ::std::os::raw::c_uint = 16;
pub const BPF_IMM: ::std::os::raw::c_uint = 0;
pub const BPF_ABS: ::std::os::raw::c_uint = 32;
pub const BPF_IND: ::std::os::raw::c_uint = 64;
pub const BPF_MEM: ::std::os::raw::c_uint = 96;
pub const BPF_LEN: ::std::os::raw::c_uint = 128;
pub const BPF_MSH: ::std::os::raw::c_uint = 160;
pub const BPF_ADD: ::std::os::raw::c_uint = 0;
pub const BPF_SUB: ::std::os::raw::c_uint = 16;
pub const BPF_MUL: ::std::os::raw::c_uint = 32;
pub const BPF_DIV: ::std::os::raw::c_uint = 48;
pub const BPF_OR: ::std::os::raw::c_uint = 64;
pub const BPF_AND: ::std::os::raw::c_uint = 80;
pub const BPF_LSH: ::std::os::raw::c_uint = 96;
pub const BPF_RSH: ::std::os::raw::c_uint = 112;
pub const BPF_NEG: ::std::os::raw::c_uint = 128;
pub const BPF_MOD: ::std::os::raw::c_uint = 144;
pub const BPF_XOR: ::std::os::raw::c_uint = 160;
pub const BPF_JA: ::std::os::raw::c_uint = 0;
pub const BPF_JEQ: ::std::os::raw::c_uint = 16;
pub const BPF_JGT: ::std::os::raw::c_uint = 32;
pub const BPF_JGE: ::std::os::raw::c_uint = 48;
pub const BPF_JSET: ::std::os::raw::c_uint = 64;
pub const BPF_K: ::std::os::raw::c_uint = 0;
pub const BPF_X: ::std::os::raw::c_uint = 8;
pub const BPF_MAXINSNS: ::std::os::raw::c_uint = 4096;
pub const BPF_ALU64: ::std::os::raw::c_uint = 7;
pub const BPF_DW: ::std::os::raw::c_uint = 24;
pub const BPF_XADD: ::std::os::raw::c_uint = 192;
pub const BPF_MOV: ::std::os::raw::c_uint = 176;
pub const BPF_ARSH: ::std::os::raw::c_uint = 192;
pub const BPF_END: ::std::os::raw::c_uint = 208;
pub const BPF_TO_LE: ::std::os::raw::c_uint = 0;
pub const BPF_TO_BE: ::std::os::raw::c_uint = 8;
pub const BPF_FROM_LE: ::std::os::raw::c_uint = 0;
pub const BPF_FROM_BE: ::std::os::raw::c_uint = 8;
pub const BPF_JNE: ::std::os::raw::c_uint = 80;
pub const BPF_JLT: ::std::os::raw::c_uint = 160;
pub const BPF_JLE: ::std::os::raw::c_uint = 176;
pub const BPF_JSGT: ::std::os::raw::c_uint = 96;
pub const BPF_JSGE: ::std::os::raw::c_uint = 112;
pub const BPF_JSLT: ::std::os::raw::c_uint = 192;
pub const BPF_JSLE: ::std::os::raw::c_uint = 208;
pub const BPF_CALL: ::std::os::raw::c_uint = 128;
pub const BPF_EXIT: ::std::os::raw::c_uint = 144;
pub const BPF_F_ALLOW_OVERRIDE: ::std::os::raw::c_uint = 1;
pub const BPF_F_ALLOW_MULTI: ::std::os::raw::c_uint = 2;
pub const BPF_F_STRICT_ALIGNMENT: ::std::os::raw::c_uint = 1;
pub const BPF_PSEUDO_MAP_FD: ::std::os::raw::c_uint = 1;
pub const BPF_ANY: ::std::os::raw::c_uint = 0;
pub const BPF_NOEXIST: ::std::os::raw::c_uint = 1;
pub const BPF_EXIST: ::std::os::raw::c_uint = 2;
pub const BPF_F_NO_PREALLOC: ::std::os::raw::c_uint = 1;
pub const BPF_F_NO_COMMON_LRU: ::std::os::raw::c_uint = 2;
pub const BPF_F_NUMA_NODE: ::std::os::raw::c_uint = 4;
pub const BPF_F_QUERY_EFFECTIVE: ::std::os::raw::c_uint = 1;
pub const BPF_OBJ_NAME_LEN: ::std::os::raw::c_uint = 16;
pub const BPF_F_RECOMPUTE_CSUM: ::std::os::raw::c_uint = 1;
pub const BPF_F_INVALIDATE_HASH: ::std::os::raw::c_uint = 2;
pub const BPF_F_HDR_FIELD_MASK: ::std::os::raw::c_uint = 15;
pub const BPF_F_PSEUDO_HDR: ::std::os::raw::c_uint = 16;
pub const BPF_F_MARK_MANGLED_0: ::std::os::raw::c_uint = 32;
pub const BPF_F_MARK_ENFORCE: ::std::os::raw::c_uint = 64;
pub const BPF_F_INGRESS: ::std::os::raw::c_uint = 1;
pub const BPF_F_TUNINFO_IPV6: ::std::os::raw::c_uint = 1;
pub const BPF_F_SKIP_FIELD_MASK: ::std::os::raw::c_uint = 255;
pub const BPF_F_USER_STACK: ::std::os::raw::c_uint = 256;
pub const BPF_F_FAST_STACK_CMP: ::std::os::raw::c_uint = 512;
pub const BPF_F_REUSE_STACKID: ::std::os::raw::c_uint = 1024;
pub const BPF_F_ZERO_CSUM_TX: ::std::os::raw::c_uint = 2;
pub const BPF_F_DONT_FRAGMENT: ::std::os::raw::c_uint = 4;
pub const BPF_F_INDEX_MASK: ::std::os::raw::c_uint = 4294967295;
pub const BPF_F_CURRENT_CPU: ::std::os::raw::c_uint = 4294967295;
pub const BPF_F_CTXLEN_MASK: ::std::os::raw::c_ulonglong = 4503595332403200;
pub const XDP_PACKET_HEADROOM: ::std::os::raw::c_uint = 256;
pub const BPF_TAG_SIZE: ::std::os::raw::c_uint = 8;
pub const TCP_BPF_IW: ::std::os::raw::c_uint = 1001;
pub const TCP_BPF_SNDCWND_CLAMP: ::std::os::raw::c_uint = 1002;
pub const LOG_BUF_SIZE: ::std::os::raw::c_uint = 65536;
pub const BPF_FN_PREFIX: &'static [u8; 9usize] = b".bpf.fn.\x00";
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::std::os::raw::c_uint,
                          __w_coredump: ::std::os::raw::c_uint,
                          __w_retcode: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__w_termsig as u32 as u32) << 0usize) &
                           (127u64 as u32))
              } | ((__w_coredump as u32 as u32) << 7usize) & (128u64 as u32))
         } | ((__w_retcode as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::std::os::raw::c_uint,
                          __w_stopsig: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__w_stopval as u32 as u32) << 0usize) & (255u64 as u32))
         } | ((__w_stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_terminated as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_terminated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_stopped as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_stopped ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (::std::mem::align_of::<__WAIT_STATUS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __uptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __uptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __iptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __iptr ) ));
}
impl Clone for __WAIT_STATUS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_module_create_b(filename: *const ::std::os::raw::c_char,
                               proto_filename: *const ::std::os::raw::c_char,
                               flags: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_module_create_c(filename: *const ::std::os::raw::c_char,
                               flags: ::std::os::raw::c_uint,
                               cflags: *mut *const ::std::os::raw::c_char,
                               ncflags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_module_create_c_from_string(text:
                                               *const ::std::os::raw::c_char,
                                           flags: ::std::os::raw::c_uint,
                                           cflags:
                                               *mut *const ::std::os::raw::c_char,
                                           ncflags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_module_destroy(program: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn bpf_module_license(program: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpf_module_kern_version(program: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bpf_num_functions(program: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn bpf_function_name(program: *mut ::std::os::raw::c_void, id: usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpf_function_start_id(program: *mut ::std::os::raw::c_void,
                                 id: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_function_start(program: *mut ::std::os::raw::c_void,
                              name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_function_size_id(program: *mut ::std::os::raw::c_void,
                                id: usize) -> usize;
}
extern "C" {
    pub fn bpf_function_size(program: *mut ::std::os::raw::c_void,
                             name: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn bpf_num_tables(program: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn bpf_table_id(program: *mut ::std::os::raw::c_void,
                        table_name: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn bpf_table_fd(program: *mut ::std::os::raw::c_void,
                        table_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_fd_id(program: *mut ::std::os::raw::c_void, id: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_type(program: *mut ::std::os::raw::c_void,
                          table_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_type_id(program: *mut ::std::os::raw::c_void, id: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_max_entries(program: *mut ::std::os::raw::c_void,
                                 table_name: *const ::std::os::raw::c_char)
     -> usize;
}
extern "C" {
    pub fn bpf_table_max_entries_id(program: *mut ::std::os::raw::c_void,
                                    id: usize) -> usize;
}
extern "C" {
    pub fn bpf_table_flags(program: *mut ::std::os::raw::c_void,
                           table_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_flags_id(program: *mut ::std::os::raw::c_void, id: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_name(program: *mut ::std::os::raw::c_void, id: usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpf_table_key_desc(program: *mut ::std::os::raw::c_void,
                              table_name: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpf_table_key_desc_id(program: *mut ::std::os::raw::c_void,
                                 id: usize) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpf_table_leaf_desc(program: *mut ::std::os::raw::c_void,
                               table_name: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpf_table_leaf_desc_id(program: *mut ::std::os::raw::c_void,
                                  id: usize) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpf_table_key_size(program: *mut ::std::os::raw::c_void,
                              table_name: *const ::std::os::raw::c_char)
     -> usize;
}
extern "C" {
    pub fn bpf_table_key_size_id(program: *mut ::std::os::raw::c_void,
                                 id: usize) -> usize;
}
extern "C" {
    pub fn bpf_table_leaf_size(program: *mut ::std::os::raw::c_void,
                               table_name: *const ::std::os::raw::c_char)
     -> usize;
}
extern "C" {
    pub fn bpf_table_leaf_size_id(program: *mut ::std::os::raw::c_void,
                                  id: usize) -> usize;
}
extern "C" {
    pub fn bpf_table_key_snprintf(program: *mut ::std::os::raw::c_void,
                                  id: usize, buf: *mut ::std::os::raw::c_char,
                                  buflen: usize,
                                  key: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_leaf_snprintf(program: *mut ::std::os::raw::c_void,
                                   id: usize,
                                   buf: *mut ::std::os::raw::c_char,
                                   buflen: usize,
                                   leaf: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_key_sscanf(program: *mut ::std::os::raw::c_void,
                                id: usize, buf: *const ::std::os::raw::c_char,
                                key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_table_leaf_sscanf(program: *mut ::std::os::raw::c_void,
                                 id: usize,
                                 buf: *const ::std::os::raw::c_char,
                                 leaf: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub const BPF_REG_0: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_0;
pub const BPF_REG_1: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_1;
pub const BPF_REG_2: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_2;
pub const BPF_REG_3: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_3;
pub const BPF_REG_4: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_4;
pub const BPF_REG_5: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_5;
pub const BPF_REG_6: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_6;
pub const BPF_REG_7: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_7;
pub const BPF_REG_8: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_8;
pub const BPF_REG_9: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_9;
pub const BPF_REG_10: _bindgen_ty_1 = _bindgen_ty_1::BPF_REG_10;
pub const __MAX_BPF_REG: _bindgen_ty_1 = _bindgen_ty_1::__MAX_BPF_REG;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    BPF_REG_0 = 0,
    BPF_REG_1 = 1,
    BPF_REG_2 = 2,
    BPF_REG_3 = 3,
    BPF_REG_4 = 4,
    BPF_REG_5 = 5,
    BPF_REG_6 = 6,
    BPF_REG_7 = 7,
    BPF_REG_8 = 8,
    BPF_REG_9 = 9,
    BPF_REG_10 = 10,
    __MAX_BPF_REG = 11,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_insn {
    pub code: __u8,
    pub _bitfield_1: u8,
    pub off: __s16,
    pub imm: __s32,
}
#[test]
fn bindgen_test_layout_bpf_insn() {
    assert_eq!(::std::mem::size_of::<bpf_insn>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bpf_insn ) ));
    assert_eq! (::std::mem::align_of::<bpf_insn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_insn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . code as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . off as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . imm as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( imm ) ));
}
impl Clone for bpf_insn {
    fn clone(&self) -> Self { *self }
}
impl bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __u8) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn src_reg(&self) -> __u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> u8 {
        ({ ({ 0 } | ((dst_reg as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((src_reg as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_lpm_trie_key {
    pub prefixlen: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_bpf_lpm_trie_key() {
    assert_eq!(::std::mem::size_of::<bpf_lpm_trie_key>() , 4usize , concat ! (
               "Size of: " , stringify ! ( bpf_lpm_trie_key ) ));
    assert_eq! (::std::mem::align_of::<bpf_lpm_trie_key>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( bpf_lpm_trie_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_lpm_trie_key ) ) . prefixlen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_lpm_trie_key ) ,
                "::" , stringify ! ( prefixlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_lpm_trie_key ) ) . data as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_lpm_trie_key ) ,
                "::" , stringify ! ( data ) ));
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_cmd {
    BPF_MAP_CREATE = 0,
    BPF_MAP_LOOKUP_ELEM = 1,
    BPF_MAP_UPDATE_ELEM = 2,
    BPF_MAP_DELETE_ELEM = 3,
    BPF_MAP_GET_NEXT_KEY = 4,
    BPF_PROG_LOAD = 5,
    BPF_OBJ_PIN = 6,
    BPF_OBJ_GET = 7,
    BPF_PROG_ATTACH = 8,
    BPF_PROG_DETACH = 9,
    BPF_PROG_TEST_RUN = 10,
    BPF_PROG_GET_NEXT_ID = 11,
    BPF_MAP_GET_NEXT_ID = 12,
    BPF_PROG_GET_FD_BY_ID = 13,
    BPF_MAP_GET_FD_BY_ID = 14,
    BPF_OBJ_GET_INFO_BY_FD = 15,
    BPF_PROG_QUERY = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_map_type {
    BPF_MAP_TYPE_UNSPEC = 0,
    BPF_MAP_TYPE_HASH = 1,
    BPF_MAP_TYPE_ARRAY = 2,
    BPF_MAP_TYPE_PROG_ARRAY = 3,
    BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
    BPF_MAP_TYPE_PERCPU_HASH = 5,
    BPF_MAP_TYPE_PERCPU_ARRAY = 6,
    BPF_MAP_TYPE_STACK_TRACE = 7,
    BPF_MAP_TYPE_CGROUP_ARRAY = 8,
    BPF_MAP_TYPE_LRU_HASH = 9,
    BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
    BPF_MAP_TYPE_LPM_TRIE = 11,
    BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
    BPF_MAP_TYPE_HASH_OF_MAPS = 13,
    BPF_MAP_TYPE_DEVMAP = 14,
    BPF_MAP_TYPE_SOCKMAP = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4,
    BPF_PROG_TYPE_TRACEPOINT = 5,
    BPF_PROG_TYPE_XDP = 6,
    BPF_PROG_TYPE_PERF_EVENT = 7,
    BPF_PROG_TYPE_CGROUP_SKB = 8,
    BPF_PROG_TYPE_CGROUP_SOCK = 9,
    BPF_PROG_TYPE_LWT_IN = 10,
    BPF_PROG_TYPE_LWT_OUT = 11,
    BPF_PROG_TYPE_LWT_XMIT = 12,
    BPF_PROG_TYPE_SOCK_OPS = 13,
    BPF_PROG_TYPE_SK_SKB = 14,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_attach_type {
    BPF_CGROUP_INET_INGRESS = 0,
    BPF_CGROUP_INET_EGRESS = 1,
    BPF_CGROUP_INET_SOCK_CREATE = 2,
    BPF_CGROUP_SOCK_OPS = 3,
    BPF_SK_SKB_STREAM_PARSER = 4,
    BPF_SK_SKB_STREAM_VERDICT = 5,
    __MAX_BPF_ATTACH_TYPE = 6,
}
#[repr(C)]
#[derive(Copy)]
pub union bpf_attr {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_attr__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_attr__bindgen_ty_4,
    pub __bindgen_anon_5: bpf_attr__bindgen_ty_5,
    pub test: bpf_attr__bindgen_ty_6,
    pub __bindgen_anon_6: bpf_attr__bindgen_ty_7,
    pub info: bpf_attr__bindgen_ty_8,
    pub query: bpf_attr__bindgen_ty_9,
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_1 {
    pub map_type: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub inner_map_fd: __u32,
    pub numa_node: __u32,
    pub map_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_1>() , 44usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . map_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( map_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . key_size as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( key_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . value_size
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( value_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . max_entries
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( max_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . map_flags as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( map_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . inner_map_fd
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( inner_map_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . numa_node as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( numa_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_1 ) ) . map_name as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_1
                ) , "::" , stringify ! ( map_name ) ));
}
impl Clone for bpf_attr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct bpf_attr__bindgen_ty_2 {
    pub map_fd: __u32,
    pub key: __u64,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy)]
pub union bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __u64,
    pub next_key: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               bpf_attr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                bpf_attr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2__bindgen_ty_1 ) )
                . value as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_attr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2__bindgen_ty_1 ) )
                . next_key as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_attr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                next_key ) ));
}
impl Clone for bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2 ) ) . map_fd as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_2
                ) , "::" , stringify ! ( map_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2 ) ) . key as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_2
                ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_2 ) ) . flags as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_2
                ) , "::" , stringify ! ( flags ) ));
}
impl Clone for bpf_attr__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_3 {
    pub prog_type: __u32,
    pub insn_cnt: __u32,
    pub insns: __u64,
    pub license: __u64,
    pub log_level: __u32,
    pub log_size: __u32,
    pub log_buf: __u64,
    pub kern_version: __u32,
    pub prog_flags: __u32,
    pub prog_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_3>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_3 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . prog_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( prog_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . insn_cnt as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( insn_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . insns as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( insns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . license as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( license ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . log_level as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( log_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . log_size as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( log_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . log_buf as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( log_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . kern_version
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( kern_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . prog_flags
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( prog_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_3 ) ) . prog_name as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_3
                ) , "::" , stringify ! ( prog_name ) ));
}
impl Clone for bpf_attr__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_4 {
    pub pathname: __u64,
    pub bpf_fd: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_4>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_4 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_4 ) ) . pathname as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_4
                ) , "::" , stringify ! ( pathname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_4 ) ) . bpf_fd as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_4
                ) , "::" , stringify ! ( bpf_fd ) ));
}
impl Clone for bpf_attr__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_5 {
    pub target_fd: __u32,
    pub attach_bpf_fd: __u32,
    pub attach_type: __u32,
    pub attach_flags: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_5>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_5 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_5>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) . target_fd as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( target_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) .
                attach_bpf_fd as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( attach_bpf_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) . attach_type
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( attach_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_5 ) ) . attach_flags
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_5
                ) , "::" , stringify ! ( attach_flags ) ));
}
impl Clone for bpf_attr__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_6 {
    pub prog_fd: __u32,
    pub retval: __u32,
    pub data_size_in: __u32,
    pub data_size_out: __u32,
    pub data_in: __u64,
    pub data_out: __u64,
    pub repeat: __u32,
    pub duration: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_6>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_6 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_6>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) . prog_fd as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( prog_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) . retval as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( retval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) . data_size_in
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( data_size_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) .
                data_size_out as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( data_size_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) . data_in as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( data_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) . data_out as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( data_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) . repeat as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( repeat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_6 ) ) . duration as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_6
                ) , "::" , stringify ! ( duration ) ));
}
impl Clone for bpf_attr__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct bpf_attr__bindgen_ty_7 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_7__bindgen_ty_1,
    pub next_id: __u32,
}
#[repr(C)]
#[derive(Copy)]
pub union bpf_attr__bindgen_ty_7__bindgen_ty_1 {
    pub start_id: __u32,
    pub prog_id: __u32,
    pub map_id: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_7__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! (
               bpf_attr__bindgen_ty_7__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_7__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                bpf_attr__bindgen_ty_7__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_7__bindgen_ty_1 ) )
                . start_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_attr__bindgen_ty_7__bindgen_ty_1 ) , "::" , stringify ! (
                start_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_7__bindgen_ty_1 ) )
                . prog_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_attr__bindgen_ty_7__bindgen_ty_1 ) , "::" , stringify ! (
                prog_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_7__bindgen_ty_1 ) )
                . map_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_attr__bindgen_ty_7__bindgen_ty_1 ) , "::" , stringify ! (
                map_id ) ));
}
impl Clone for bpf_attr__bindgen_ty_7__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_7>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_7 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_7>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_7 ) ) . next_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_7
                ) , "::" , stringify ! ( next_id ) ));
}
impl Clone for bpf_attr__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_8 {
    pub bpf_fd: __u32,
    pub info_len: __u32,
    pub info: __u64,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_8>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_8 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_8>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_8 ) ) . bpf_fd as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_8
                ) , "::" , stringify ! ( bpf_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_8 ) ) . info_len as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_8
                ) , "::" , stringify ! ( info_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_8 ) ) . info as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_8
                ) , "::" , stringify ! ( info ) ));
}
impl Clone for bpf_attr__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_attr__bindgen_ty_9 {
    pub target_fd: __u32,
    pub attach_type: __u32,
    pub query_flags: __u32,
    pub attach_flags: __u32,
    pub prog_ids: __u64,
    pub prog_cnt: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<bpf_attr__bindgen_ty_9>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_attr__bindgen_ty_9 )
               ));
    assert_eq! (::std::mem::align_of::<bpf_attr__bindgen_ty_9>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_attr__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_9 ) ) . target_fd as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_9
                ) , "::" , stringify ! ( target_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_9 ) ) . attach_type
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_9
                ) , "::" , stringify ! ( attach_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_9 ) ) . query_flags
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_9
                ) , "::" , stringify ! ( query_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_9 ) ) . attach_flags
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_9
                ) , "::" , stringify ! ( attach_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_9 ) ) . prog_ids as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_9
                ) , "::" , stringify ! ( prog_ids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr__bindgen_ty_9 ) ) . prog_cnt as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr__bindgen_ty_9
                ) , "::" , stringify ! ( prog_cnt ) ));
}
impl Clone for bpf_attr__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_attr() {
    assert_eq!(::std::mem::size_of::<bpf_attr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( bpf_attr ) ));
    assert_eq! (::std::mem::align_of::<bpf_attr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr ) ) . test as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr ) , "::" ,
                stringify ! ( test ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr ) ) . info as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr ) , "::" ,
                stringify ! ( info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_attr ) ) . query as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_attr ) , "::" ,
                stringify ! ( query ) ));
}
impl Clone for bpf_attr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_func_id {
    BPF_FUNC_unspec = 0,
    BPF_FUNC_map_lookup_elem = 1,
    BPF_FUNC_map_update_elem = 2,
    BPF_FUNC_map_delete_elem = 3,
    BPF_FUNC_probe_read = 4,
    BPF_FUNC_ktime_get_ns = 5,
    BPF_FUNC_trace_printk = 6,
    BPF_FUNC_get_prandom_u32 = 7,
    BPF_FUNC_get_smp_processor_id = 8,
    BPF_FUNC_skb_store_bytes = 9,
    BPF_FUNC_l3_csum_replace = 10,
    BPF_FUNC_l4_csum_replace = 11,
    BPF_FUNC_tail_call = 12,
    BPF_FUNC_clone_redirect = 13,
    BPF_FUNC_get_current_pid_tgid = 14,
    BPF_FUNC_get_current_uid_gid = 15,
    BPF_FUNC_get_current_comm = 16,
    BPF_FUNC_get_cgroup_classid = 17,
    BPF_FUNC_skb_vlan_push = 18,
    BPF_FUNC_skb_vlan_pop = 19,
    BPF_FUNC_skb_get_tunnel_key = 20,
    BPF_FUNC_skb_set_tunnel_key = 21,
    BPF_FUNC_perf_event_read = 22,
    BPF_FUNC_redirect = 23,
    BPF_FUNC_get_route_realm = 24,
    BPF_FUNC_perf_event_output = 25,
    BPF_FUNC_skb_load_bytes = 26,
    BPF_FUNC_get_stackid = 27,
    BPF_FUNC_csum_diff = 28,
    BPF_FUNC_skb_get_tunnel_opt = 29,
    BPF_FUNC_skb_set_tunnel_opt = 30,
    BPF_FUNC_skb_change_proto = 31,
    BPF_FUNC_skb_change_type = 32,
    BPF_FUNC_skb_under_cgroup = 33,
    BPF_FUNC_get_hash_recalc = 34,
    BPF_FUNC_get_current_task = 35,
    BPF_FUNC_probe_write_user = 36,
    BPF_FUNC_current_task_under_cgroup = 37,
    BPF_FUNC_skb_change_tail = 38,
    BPF_FUNC_skb_pull_data = 39,
    BPF_FUNC_csum_update = 40,
    BPF_FUNC_set_hash_invalid = 41,
    BPF_FUNC_get_numa_node_id = 42,
    BPF_FUNC_skb_change_head = 43,
    BPF_FUNC_xdp_adjust_head = 44,
    BPF_FUNC_probe_read_str = 45,
    BPF_FUNC_get_socket_cookie = 46,
    BPF_FUNC_get_socket_uid = 47,
    BPF_FUNC_set_hash = 48,
    BPF_FUNC_setsockopt = 49,
    BPF_FUNC_skb_adjust_room = 50,
    BPF_FUNC_redirect_map = 51,
    BPF_FUNC_sk_redirect_map = 52,
    BPF_FUNC_sock_map_update = 53,
    BPF_FUNC_xdp_adjust_meta = 54,
    BPF_FUNC_perf_event_read_value = 55,
    BPF_FUNC_perf_prog_read_value = 56,
    __BPF_FUNC_MAX_ID = 57,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_adj_room_mode { BPF_ADJ_ROOM_NET = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sk_buff {
    pub len: __u32,
    pub pkt_type: __u32,
    pub mark: __u32,
    pub queue_mapping: __u32,
    pub protocol: __u32,
    pub vlan_present: __u32,
    pub vlan_tci: __u32,
    pub vlan_proto: __u32,
    pub priority: __u32,
    pub ingress_ifindex: __u32,
    pub ifindex: __u32,
    pub tc_index: __u32,
    pub cb: [__u32; 5usize],
    pub hash: __u32,
    pub tc_classid: __u32,
    pub data: __u32,
    pub data_end: __u32,
    pub napi_id: __u32,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub data_meta: __u32,
}
#[test]
fn bindgen_test_layout___sk_buff() {
    assert_eq!(::std::mem::size_of::<__sk_buff>() , 144usize , concat ! (
               "Size of: " , stringify ! ( __sk_buff ) ));
    assert_eq! (::std::mem::align_of::<__sk_buff>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sk_buff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . len as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . pkt_type as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( pkt_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . mark as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . queue_mapping as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( queue_mapping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . protocol as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . vlan_present as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( vlan_present ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . vlan_tci as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( vlan_tci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . vlan_proto as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( vlan_proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . priority as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . ingress_ifindex as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( ingress_ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . ifindex as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . tc_index as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( tc_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . cb as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . hash as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . tc_classid as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( tc_classid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . data as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . data_end as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( data_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . napi_id as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( napi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . family as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . remote_ip4 as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( remote_ip4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . local_ip4 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( local_ip4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . remote_ip6 as * const _
                as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( remote_ip6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . local_ip6 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( local_ip6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . remote_port as * const _
                as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( remote_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . local_port as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( local_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sk_buff ) ) . data_meta as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( __sk_buff ) , "::" ,
                stringify ! ( data_meta ) ));
}
impl Clone for __sk_buff {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct bpf_tunnel_key {
    pub tunnel_id: __u32,
    pub __bindgen_anon_1: bpf_tunnel_key__bindgen_ty_1,
    pub tunnel_tos: __u8,
    pub tunnel_ttl: __u8,
    pub tunnel_ext: __u16,
    pub tunnel_label: __u32,
}
#[repr(C)]
#[derive(Copy)]
pub union bpf_tunnel_key__bindgen_ty_1 {
    pub remote_ipv4: __u32,
    pub remote_ipv6: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_bpf_tunnel_key__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_tunnel_key__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( bpf_tunnel_key__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<bpf_tunnel_key__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_tunnel_key__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key__bindgen_ty_1 ) ) .
                remote_ipv4 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_tunnel_key__bindgen_ty_1 ) , "::" , stringify ! (
                remote_ipv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key__bindgen_ty_1 ) ) .
                remote_ipv6 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_tunnel_key__bindgen_ty_1 ) , "::" , stringify ! (
                remote_ipv6 ) ));
}
impl Clone for bpf_tunnel_key__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_tunnel_key() {
    assert_eq!(::std::mem::size_of::<bpf_tunnel_key>() , 28usize , concat ! (
               "Size of: " , stringify ! ( bpf_tunnel_key ) ));
    assert_eq! (::std::mem::align_of::<bpf_tunnel_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_tunnel_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_tos as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_tos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_ttl as *
                const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_ttl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_ext as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_tunnel_key ) ) . tunnel_label as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_tunnel_key ) , "::"
                , stringify ! ( tunnel_label ) ));
}
impl Clone for bpf_tunnel_key {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_ret_code { BPF_OK = 0, BPF_DROP = 2, BPF_REDIRECT = 7, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_sock {
    pub bound_dev_if: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
    pub mark: __u32,
    pub priority: __u32,
}
#[test]
fn bindgen_test_layout_bpf_sock() {
    assert_eq!(::std::mem::size_of::<bpf_sock>() , 24usize , concat ! (
               "Size of: " , stringify ! ( bpf_sock ) ));
    assert_eq! (::std::mem::align_of::<bpf_sock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_sock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . bound_dev_if as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( bound_dev_if ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . family as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . protocol as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . mark as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock ) ) . priority as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock ) , "::" ,
                stringify ! ( priority ) ));
}
impl Clone for bpf_sock {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xdp_action {
    XDP_ABORTED = 0,
    XDP_DROP = 1,
    XDP_PASS = 2,
    XDP_TX = 3,
    XDP_REDIRECT = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xdp_md {
    pub data: __u32,
    pub data_end: __u32,
    pub data_meta: __u32,
}
#[test]
fn bindgen_test_layout_xdp_md() {
    assert_eq!(::std::mem::size_of::<xdp_md>() , 12usize , concat ! (
               "Size of: " , stringify ! ( xdp_md ) ));
    assert_eq! (::std::mem::align_of::<xdp_md>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( xdp_md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xdp_md ) ) . data as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xdp_md ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xdp_md ) ) . data_end as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xdp_md ) , "::" ,
                stringify ! ( data_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xdp_md ) ) . data_meta as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xdp_md ) , "::" ,
                stringify ! ( data_meta ) ));
}
impl Clone for xdp_md {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_action { SK_ABORTED = 0, SK_DROP = 1, SK_REDIRECT = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_prog_info {
    pub type_: __u32,
    pub id: __u32,
    pub tag: [__u8; 8usize],
    pub jited_prog_len: __u32,
    pub xlated_prog_len: __u32,
    pub jited_prog_insns: __u64,
    pub xlated_prog_insns: __u64,
    pub load_time: __u64,
    pub created_by_uid: __u32,
    pub nr_map_ids: __u32,
    pub map_ids: __u64,
    pub name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_bpf_prog_info() {
    assert_eq!(::std::mem::size_of::<bpf_prog_info>() , 80usize , concat ! (
               "Size of: " , stringify ! ( bpf_prog_info ) ));
    assert_eq! (::std::mem::align_of::<bpf_prog_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_prog_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . id as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . tag as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . jited_prog_len as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( jited_prog_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . xlated_prog_len as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( xlated_prog_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . jited_prog_insns as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( jited_prog_insns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . xlated_prog_insns as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( xlated_prog_insns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . load_time as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( load_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . created_by_uid as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( created_by_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . nr_map_ids as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( nr_map_ids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . map_ids as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( map_ids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_prog_info ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_prog_info ) , "::"
                , stringify ! ( name ) ));
}
impl Clone for bpf_prog_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_map_info {
    pub type_: __u32,
    pub id: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub name: [::std::os::raw::c_char; 16usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_bpf_map_info() {
    assert_eq!(::std::mem::size_of::<bpf_map_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( bpf_map_info ) ));
    assert_eq! (::std::mem::align_of::<bpf_map_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_map_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_map_info ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_map_info ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_map_info ) ) . id as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_map_info ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_map_info ) ) . key_size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_map_info ) , "::" ,
                stringify ! ( key_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_map_info ) ) . value_size as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_map_info ) , "::" ,
                stringify ! ( value_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_map_info ) ) . max_entries as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_map_info ) , "::" ,
                stringify ! ( max_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_map_info ) ) . map_flags as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_map_info ) , "::" ,
                stringify ! ( map_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_map_info ) ) . name as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_map_info ) , "::" ,
                stringify ! ( name ) ));
}
impl Clone for bpf_map_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct bpf_sock_ops {
    pub op: __u32,
    pub __bindgen_anon_1: bpf_sock_ops__bindgen_ty_1,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
}
#[repr(C)]
#[derive(Copy)]
pub union bpf_sock_ops__bindgen_ty_1 {
    pub reply: __u32,
    pub replylong: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_bpf_sock_ops__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<bpf_sock_ops__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( bpf_sock_ops__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<bpf_sock_ops__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( bpf_sock_ops__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops__bindgen_ty_1 ) ) . reply as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_sock_ops__bindgen_ty_1 ) , "::" , stringify ! ( reply )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops__bindgen_ty_1 ) ) .
                replylong as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_sock_ops__bindgen_ty_1 ) , "::" , stringify ! ( replylong
                ) ));
}
impl Clone for bpf_sock_ops__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_bpf_sock_ops() {
    assert_eq!(::std::mem::size_of::<bpf_sock_ops>() , 72usize , concat ! (
               "Size of: " , stringify ! ( bpf_sock_ops ) ));
    assert_eq! (::std::mem::align_of::<bpf_sock_ops>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_sock_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . op as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . family as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . remote_ip4 as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( remote_ip4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . local_ip4 as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( local_ip4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . remote_ip6 as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( remote_ip6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . local_ip6 as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( local_ip6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . remote_port as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( remote_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_sock_ops ) ) . local_port as * const
                _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_sock_ops ) , "::" ,
                stringify ! ( local_port ) ));
}
impl Clone for bpf_sock_ops {
    fn clone(&self) -> Self { *self }
}
pub const BPF_SOCK_OPS_VOID: _bindgen_ty_2 = _bindgen_ty_2::BPF_SOCK_OPS_VOID;
pub const BPF_SOCK_OPS_TIMEOUT_INIT: _bindgen_ty_2 =
    _bindgen_ty_2::BPF_SOCK_OPS_TIMEOUT_INIT;
pub const BPF_SOCK_OPS_RWND_INIT: _bindgen_ty_2 =
    _bindgen_ty_2::BPF_SOCK_OPS_RWND_INIT;
pub const BPF_SOCK_OPS_TCP_CONNECT_CB: _bindgen_ty_2 =
    _bindgen_ty_2::BPF_SOCK_OPS_TCP_CONNECT_CB;
pub const BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB: _bindgen_ty_2 =
    _bindgen_ty_2::BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB;
pub const BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: _bindgen_ty_2 =
    _bindgen_ty_2::BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB;
pub const BPF_SOCK_OPS_NEEDS_ECN: _bindgen_ty_2 =
    _bindgen_ty_2::BPF_SOCK_OPS_NEEDS_ECN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    BPF_SOCK_OPS_VOID = 0,
    BPF_SOCK_OPS_TIMEOUT_INIT = 1,
    BPF_SOCK_OPS_RWND_INIT = 2,
    BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
    BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
    BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
    BPF_SOCK_OPS_NEEDS_ECN = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_perf_event_value {
    pub counter: __u64,
    pub enabled: __u64,
    pub running: __u64,
}
#[test]
fn bindgen_test_layout_bpf_perf_event_value() {
    assert_eq!(::std::mem::size_of::<bpf_perf_event_value>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( bpf_perf_event_value )
               ));
    assert_eq! (::std::mem::align_of::<bpf_perf_event_value>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_perf_event_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_perf_event_value ) ) . counter as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_perf_event_value )
                , "::" , stringify ! ( counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_perf_event_value ) ) . enabled as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_perf_event_value )
                , "::" , stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_perf_event_value ) ) . running as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_perf_event_value )
                , "::" , stringify ! ( running ) ));
}
impl Clone for bpf_perf_event_value {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_probe_attach_type { BPF_PROBE_ENTRY = 0, BPF_PROBE_RETURN = 1, }
extern "C" {
    pub fn bpf_create_map(map_type: bpf_map_type,
                          key_size: ::std::os::raw::c_int,
                          value_size: ::std::os::raw::c_int,
                          max_entries: ::std::os::raw::c_int,
                          map_flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_update_elem(fd: ::std::os::raw::c_int,
                           key: *mut ::std::os::raw::c_void,
                           value: *mut ::std::os::raw::c_void,
                           flags: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_lookup_elem(fd: ::std::os::raw::c_int,
                           key: *mut ::std::os::raw::c_void,
                           value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_delete_elem(fd: ::std::os::raw::c_int,
                           key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_get_first_key(fd: ::std::os::raw::c_int,
                             key: *mut ::std::os::raw::c_void,
                             key_size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_get_next_key(fd: ::std::os::raw::c_int,
                            key: *mut ::std::os::raw::c_void,
                            next_key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_prog_load(prog_type: bpf_prog_type, insns: *const bpf_insn,
                         insn_len: ::std::os::raw::c_int,
                         license: *const ::std::os::raw::c_char,
                         kern_version: ::std::os::raw::c_uint,
                         log_buf: *mut ::std::os::raw::c_char,
                         log_buf_size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_attach_socket(sockfd: ::std::os::raw::c_int,
                             progfd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_open_raw_sock(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type perf_reader_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_cookie:
                                                   *mut ::std::os::raw::c_void,
                                               pid: ::std::os::raw::c_int,
                                               callchain_num: u64,
                                               callchain:
                                                   *mut ::std::os::raw::c_void)>;
pub type perf_reader_raw_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_cookie:
                                                   *mut ::std::os::raw::c_void,
                                               raw:
                                                   *mut ::std::os::raw::c_void,
                                               raw_size:
                                                   ::std::os::raw::c_int)>;
pub type perf_reader_lost_cb =
    ::std::option::Option<unsafe extern "C" fn(lost: u64)>;
extern "C" {
    pub fn bpf_attach_kprobe(progfd: ::std::os::raw::c_int,
                             attach_type: bpf_probe_attach_type,
                             ev_name: *const ::std::os::raw::c_char,
                             fn_name: *const ::std::os::raw::c_char,
                             pid: pid_t, cpu: ::std::os::raw::c_int,
                             group_fd: ::std::os::raw::c_int,
                             cb: perf_reader_cb,
                             cb_cookie: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_detach_kprobe(ev_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_attach_uprobe(progfd: ::std::os::raw::c_int,
                             attach_type: bpf_probe_attach_type,
                             ev_name: *const ::std::os::raw::c_char,
                             binary_path: *const ::std::os::raw::c_char,
                             offset: u64, pid: pid_t,
                             cpu: ::std::os::raw::c_int,
                             group_fd: ::std::os::raw::c_int,
                             cb: perf_reader_cb,
                             cb_cookie: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_detach_uprobe(ev_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_attach_tracepoint(progfd: ::std::os::raw::c_int,
                                 tp_category: *const ::std::os::raw::c_char,
                                 tp_name: *const ::std::os::raw::c_char,
                                 pid: ::std::os::raw::c_int,
                                 cpu: ::std::os::raw::c_int,
                                 group_fd: ::std::os::raw::c_int,
                                 cb: perf_reader_cb,
                                 cb_cookie: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_detach_tracepoint(tp_category: *const ::std::os::raw::c_char,
                                 tp_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_open_perf_buffer(raw_cb: perf_reader_raw_cb,
                                lost_cb: perf_reader_lost_cb,
                                cb_cookie: *mut ::std::os::raw::c_void,
                                pid: ::std::os::raw::c_int,
                                cpu: ::std::os::raw::c_int,
                                page_cnt: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bpf_attach_xdp(dev_name: *const ::std::os::raw::c_char,
                          progfd: ::std::os::raw::c_int, flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_attach_perf_event(progfd: ::std::os::raw::c_int, ev_type: u32,
                                 ev_config: u32, sample_period: u64,
                                 sample_freq: u64, pid: pid_t,
                                 cpu: ::std::os::raw::c_int,
                                 group_fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_open_perf_event(type_: u32, config: u64,
                               pid: ::std::os::raw::c_int,
                               cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_close_perf_event_fd(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_obj_pin(fd: ::std::os::raw::c_int,
                       pathname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_obj_get(pathname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_obj_get_info(prog_map_fd: ::std::os::raw::c_int,
                            info: *mut ::std::os::raw::c_void,
                            info_len: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_prog_compute_tag(insns: *const bpf_insn,
                                prog_len: ::std::os::raw::c_int,
                                tag: *mut ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpf_prog_get_tag(fd: ::std::os::raw::c_int,
                            tag: *mut ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_reader {
    _unused: [u8; 0],
}
extern "C" {
    pub fn perf_reader_new(cb: perf_reader_cb, raw_cb: perf_reader_raw_cb,
                           lost_cb: perf_reader_lost_cb,
                           cb_cookie: *mut ::std::os::raw::c_void,
                           page_cnt: ::std::os::raw::c_int)
     -> *mut perf_reader;
}
extern "C" {
    pub fn perf_reader_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn perf_reader_mmap(reader: *mut perf_reader,
                            type_: ::std::os::raw::c_uint,
                            sample_type: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perf_reader_event_read(reader: *mut perf_reader);
}
extern "C" {
    pub fn perf_reader_poll(num_readers: ::std::os::raw::c_int,
                            readers: *mut *mut perf_reader,
                            timeout: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perf_reader_fd(reader: *mut perf_reader) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perf_reader_set_fd(reader: *mut perf_reader,
                              fd: ::std::os::raw::c_int);
}
